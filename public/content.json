{"pages":[{"title":"About","date":"2018-12-25T13:05:43.217Z","path":"about/index.html","text":""},{"title":"Categories","date":"2018-12-25T13:05:43.217Z","path":"categories/index.html","text":""},{"title":"Tags","date":"2018-12-25T13:05:43.219Z","path":"tags/index.html","text":""}],"posts":[{"title":"将时间戳转换为格式化日期","date":"2018-12-14T02:51:00.000Z","path":"wiki/oh-my-article/js/transform-timestamp-to-format-time/","text":"timestamp 缺省表示使用当前时间戳，formats 默认格式是 YYYY-MM-DD HH:mm:ss，例如 2000-01-01 12:00:00。 123456789101112131415161718192021222324252627282930/** 时间戳转换成指定格式日期* eg. * dateFormat(11111111111111, 'YYYY年MM月DD日 HH时mm分')* → \"2322年02月06日 03时45分\"*/function dateFormat (timestamp, formats) &#123; formats = formats || 'YYYY-MM-DD HH:mm:ss' var date = timestamp ? new Date(timestamp) : new Date() var zero = function (num) &#123; if (num &lt; 10) &#123; return '0' + num &#125; return num &#125; var dateObj = &#123; YYYY: date.getFullYear(), MM: zero(date.getMonth() + 1), DD: zero(date.getDate()), HH: zero(date.getHours()), mm: zero(date.getMinutes()), ss: zero(date.getSeconds()), &#125; return formats.replace(/YYYY|MM|DD|HH|mm|ss/ig, function (matches) &#123; return dateObj[matches] &#125;)&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"https://wencaizhang.gitee.io/tags/javascript/"},{"name":"时间戳","slug":"时间戳","permalink":"https://wencaizhang.gitee.io/tags/时间戳/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"js","slug":"oh-my-article/js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/"}]},{"title":"按钮添加一个类名自动变loading动画版","date":"2018-12-13T02:51:00.000Z","path":"wiki/oh-my-article/js/按钮添加一个类名自动变loading动画版/","text":"有了下面的 css 代码，给任意的标签（button、a、span等等）加上一个类名 spin-loading，标签自动变成 loading 状态，方便快捷效果好。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* 按钮loading */.spin-loading &#123; position: relative;&#125;.spin-loading::before &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; /* center */ width: 4px; height: 4px; content: ''; -webkit-animation: spinZoom 1s steps(8) infinite; animation: spinZoom 1s steps(8) infinite; border-radius: 100%; box-shadow: 0 -10px 0 1px currentColor, 10px 0 currentColor, 0 10px currentColor, -10px 0 currentColor, -7px -7px 0 .5px currentColor, 7px -7px 0 1.5px currentColor, 7px 7px currentColor, -7px 7px currentColor;&#125;/* loading动画 */@-webkit-keyframes spinZoom &#123; 0% &#123; -webkit-transform: scale(.75) rotate(0); &#125; 100% &#123; -webkit-transform: scale(.75) rotate(360deg); &#125;&#125;@keyframes spinZoom &#123; 0% &#123; transform: scale(.75) rotate(0); &#125; 100% &#123; transform: scale(.75) rotate(360deg); &#125;&#125;","tags":[{"name":"css","slug":"css","permalink":"https://wencaizhang.gitee.io/tags/css/"},{"name":"loading","slug":"loading","permalink":"https://wencaizhang.gitee.io/tags/loading/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"js","slug":"oh-my-article/js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/"}]},{"title":"时间戳显示为多少分钟前，多少天前的JS处理","date":"2018-12-13T02:51:00.000Z","path":"wiki/oh-my-article/js/时间戳显示为多少分钟前，多少天前的JS处理/","text":"方法名为 getTimeAgoAt，支持一个时间戳参数 stamptime（必需）。 先上代码因为后端返回时间戳通常精确到秒（10位），而 JS 获取时间戳精确到毫秒（13位），本方法处理以秒进行计算。 1234567891011121314151617181920212223function getTimeAgoAt(stamptime) &#123; var currentStamptime = Date.parse(new Date()) / 1000; var agoAt = '刚刚'; var diff = currentStamptime - stamptime; var points = [ &#123; value: 365 * 24 * 60 * 60, suffix: '年前', max: 2 &#125;, &#123; value: 30 * 24 * 60 * 60, suffix: '月前', max: 11 &#125;, &#123; value: 7 * 24 * 60 * 60, suffix: '周前', max: 4 &#125;, &#123; value: 24 * 60 * 60, suffix: '天前', max: 6 &#125;, &#123; value: 60 * 60, suffix: '小时前', max: 23 &#125;, &#123; value: 10 * 60, suffix: '0分钟前', max: 5 &#125; ]; for (var i = 0; i &lt; points.length; i++) &#123; var item = points[i]; var mode = Math.floor(diff / item.value); if (mode &gt;= 1) &#123; agoAt = Math.min(mode, item.max) + item.suffix; break; &#125; &#125; return agoAt;&#125; 代码解析为了帮助大家理解，同时也为了备忘，这里简单解释一下子。 本方法分为两部分，数据部分（ 数组 points）和逻辑部分（遍历）。 数组 points 中每项元素都是一个时间点（对象），它拥有三个属性： suffix: 最终结果的文字后缀部分，例如最终结果是“2年前”，则“年前”由 suffix 属性而来，2 是后面的计算得来；另外，它还有指代时间单位的功能，例如通过“年前”，就可以看出其时间单位是“年”。 value: 将 suffix 指代的时间单位换算成秒 max: 当前时间单位的最大值，例如时间单位是“小时前”的时候，因为一天只有24小时，所以 max 应当是 23，它和它的更大一级的时间单位有关。 另外可以看到 points 的元素顺序按照时间单位由大到小排序，分别是“年”，“月”，“周”等等。 而逻辑部分（for 循环），则是逐个判断当前时间和通过参数传入的时间差和每个时间单位的商是否大于或等于 1 。如果商大于或等于 1，那么就直接对商进行处理，拼接成我们想要的结果，然后跳出循环。 拼接的时候取的是商和 max 属性值的较小者，事实上直接取商的值就可以，但是考虑到一些特殊情况，比如本方法中以“年”为单位的时候其 max 属性值为 2，其用意是当实际时间远大于“2两年前”的时候，不管是“3年前”还是“4年前”，返回的结果一律都是“2年前”。因此这里使用了商和 max 属性值的较小者和 suffix 进行拼接。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://wencaizhang.gitee.io/tags/javascript/"},{"name":"时间戳","slug":"时间戳","permalink":"https://wencaizhang.gitee.io/tags/时间戳/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"js","slug":"oh-my-article/js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/"}]},{"title":"anywhere使用笔记","date":"2018-12-13T02:51:00.000Z","path":"wiki/oh-my-article/js/launch-a-node-server-via-anywhere/","text":"随时随地将你的当前目录变成一个静态文件服务器的根目录 场景某天你需要临时把自己的电脑当做一个静态服务器，你可以选择使用 nginx，但如果你不想写一些复杂的配置，仅仅是想把某个目录向外暴露，那么你还可以选择 anywhere。 anywhere 是一个 nodejs 的 npm 包，安装和使用都非常的简单。 全局安装需要提前安装 nodejs 1npm install anywhere -g 命令介绍仅有一个命令命令 anywhere 会将当前目录作为服务器根目录，调用默认浏览器在默认端口 8000 打开主页。 1anywhere 如果你需要指定端口：1anywhere -p 1234 甚至你可以忽略 -p，命令后面直接紧跟端口号： 1anywhere 1234 如果你不想调用让浏览器直接打开主页当你在 linux 服务器上面使用时，这会很有用。 1anywhere -s 如果你想指定服务器根目录根目录默认是命令行当前目录，但你也可以自己指定 可以指定绝对路径 1anywhere /home 也可以指定相对路径 1anywhere ./www 如果你想指定服务器首页anywhere 命令会默认打开根目录下的 index.html 当做首页，你可以手动指定另外一个 html 文件当做首页。 1anywhere -f login.html 如果你想指定主机名anywhere 启动的服务器默认主机名是本机的 ip 地址，你可以指定为 localhost 1anywhere -h localhost 最后如果你忘记某个参数，随时可以使用 anywhere --help 查看帮助手册。 或者查看 anywhere 文档：https://www.npmjs.com/package/anywhere","tags":[{"name":"server","slug":"server","permalink":"https://wencaizhang.gitee.io/tags/server/"},{"name":"node","slug":"node","permalink":"https://wencaizhang.gitee.io/tags/node/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"js","slug":"oh-my-article/js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/"}]},{"title":"js 中使用 let 和 const 的总结","date":"2018-10-14T03:51:14.000Z","path":"wiki/oh-my-article/js/2018-10/difference-of-let-and-const/","text":"ES6 引入了 let 命令用于声明变量，引入了 const 命令用于声明常量。然而仅仅知道这些是不够的，具体哪些场景下使用 let，哪些场景使用 const 仍然令人感到疑惑。 这两个命令的学习可参考文章：let 和 const 命令，这里只参考下面一段话： const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const 只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。 因此，我认为声明简单类型数据（数字、字符串、布尔值）的时候使用 let，而在声明引用类型（对象、数组）的时候使用 const。 参考 let 和 const 命令 js中 let var const 的差异和使用场景","tags":[{"name":"javascript","slug":"javascript","permalink":"https://wencaizhang.gitee.io/tags/javascript/"},{"name":"es6","slug":"es6","permalink":"https://wencaizhang.gitee.io/tags/es6/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"js","slug":"oh-my-article/js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/"},{"name":"2018-10","slug":"oh-my-article/js/2018-10","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/2018-10/"}]},{"title":"为 Markdown 写作配置七牛云图床","date":"2018-10-12T12:20:51.000Z","path":"wiki/oh-my-article/tool/upload-markdown-picture-to-qiniuyun/","text":"What is This使用 Markdown 写作大家带来了很大的方便，但是如何处理图片一直是个问题，这里分享一个我使用的解决方案。 如何使用首先要拥有一个七牛云的账号（七牛云注册地址），然后通过 Chrome 网上应用商店安装 qiniu upload files 插件（点击这里进行安装）。 插件安装之后进行配置（截图如下）： AccessKey 和 SecretKey 可以从七牛云网站个人面板下的密钥管理界面获取 域名末尾记得加上 /，否则插件生成的链接可能有问题 bucket 是创建的储存空间的名字 其他配置项可以不填 可能有用的链接： qiniu upload files 插件下载地址 七牛云注册地址","tags":[{"name":"markdown","slug":"markdown","permalink":"https://wencaizhang.gitee.io/tags/markdown/"},{"name":"图床","slug":"图床","permalink":"https://wencaizhang.gitee.io/tags/图床/"},{"name":"chrome 插件","slug":"chrome-插件","permalink":"https://wencaizhang.gitee.io/tags/chrome-插件/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"tool","slug":"oh-my-article/tool","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/tool/"}]},{"title":"如何查找数组中指定元素","date":"2018-10-09T08:51:14.000Z","path":"wiki/oh-my-article/js/2018-10/array-find/","text":"场景我们经常会遇到这样的情况：假设现在有下面这样一个数组，现在需要在该数组中找到 id 等于 2 的元素。 123456const arr = [ &#123; id: 1, text: '11111' &#125;, &#123; id: 2, text: '22222' &#125;, &#123; id: 3, text: '33333' &#125;, &#123; id: 4, text: '44444' &#125;,] 这个问题有很多解决的方法，例如：遍历然后逐个元素进行判断。 12345678var target;for (var i = 0; i &lt; arr.length; i++) &#123; var item = arr[i]; if (item.id == 2) &#123; target = item &#125;&#125;console.log(target); // &#123;id: 2, text: \"22222\"&#125; 这里有一个简单的方法，实现如下 123const target = arr.find(item =&gt; item.id == 2)console.log(target) // &#123;id: 2, text: \"22222\"&#125; 描述find 方法用于找出第一个符合条件的数组元素。如果没有符合条件的元素，则返回 undefined。 find 方法第一个参数是一个回调函数，而这个判断条件是此回调函数的返回值是否为 true（这里会对返回值进行隐式转换）。 数组中每一项元素依次执行该回调函数，直到找到第一个返回值为 true 的元素，方法停止执行，然后返回该元素。 find 方法还可以接收第二个参数用于指定回调函数的 this 指向。 回调函数默认接收三个参数find 方法的第一个参数默认接收三个参数，第一个是遍历的数组元素，第二个是对应的数组索引，第三个是数组本身。 123456789const arr = [ 'a', 'b', 'c' ]arr.find((value, index, array) =&gt; &#123; console.log(value, index, array)&#125;)// a 0 [\"a\", \"b\", \"c\"]// b 1 [\"a\", \"b\", \"c\"]// c 2 [\"a\", \"b\", \"c\"] find() 的返回值有符合条件的，返回该数组元素，没有符合条件的，返回 undefined 1234567const arr = [ 'a', 'b', 'c' ];const result1 = arr.find(v =&gt; v == 'c')console.log(result1) // \"c\"const result2 = arr.find(v =&gt; v == 'xyz')console.log(result2) // undefined 找到第一个符合条件的，方法立即结束执行12345678910const arr = [ 'a', 'b', 'b', 'c' ];const result = arr.find(value =&gt; &#123; console.log(value); return value == 'b';&#125;);// \"a\"// \"b\"console.log(result); // \"b\" 指定 callback 执行时的 this 指向1234567const ages = [ 10, 12, 26, 15 ];const person = &#123; name: 'John', age: 20 &#125;;const age = ages.find(value =&gt; &#123; return value &gt; this.age;&#125;, person);console.log(age); // 26 简易实现find 方法在 ES6 中提出，尚未被所有浏览器实现，这里有一个简易版的实现方法。 1234567891011121314Array.prototype.find = function (callback, context) &#123; if (!this instanceof Array) &#123; return;&#125; var bool, target; for (var i = 0; i &lt; this.length; i++) &#123; bool = !!callback.call(context, this[i], i, this); if (bool) &#123; target = this[i]; break; &#125; &#125; return target&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"https://wencaizhang.gitee.io/tags/javascript/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es6","slug":"es6","permalink":"https://wencaizhang.gitee.io/tags/es6/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"js","slug":"oh-my-article/js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/"},{"name":"2018-10","slug":"oh-my-article/js/2018-10","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/2018-10/"}]},{"title":"小程序列表页的下拉刷新","date":"2018-10-06T07:43:23.000Z","path":"wiki/oh-my-article/小程序/小程序列表页的下拉刷新/","text":"下拉刷新，我们可以使用 onPullDownRefresh() 方法，对此小程序文档是这么说的： 需要在 app.json 的 window 选项中或页面配置中开启 enablePullDownRefresh。 可以通过 wx.startPullDownRefresh 触发下拉刷新，调用后触发下拉刷新动画，效果与用户手动下拉刷新一致。 当处理完数据刷新后，wx.stopPullDownRefresh 可以停止当前页面的下拉刷新。 代码实例第一步：开启 enablePullDownRefresh配置 app.json 123window: &#123; enablePullDownRefresh: true,&#125; 或者修改页面配置 123&#123; \"enablePullDownRefresh\": true&#125; 第二步：监听下拉刷新事件123456789101112131415161718192021222324252627282930313233343536Page(&#123; data: &#123; pageSize: 10, currPage: 0, list: [] &#125;, onLoad() &#123; this.fetchData(); &#125;, onPullDownRefresh() &#123; this.fetchData(); &#125;, fetchData() &#123; const self = this; const &#123; pageSize, currPage, list &#125; = this.data; // 这个方法用于请求数据， wx.request(&#123; url: \"test.php\", // 仅为示例，并非真实的接口地址 data: &#123; pageSize, currPage: currPage + 1 &#125;, success(res) &#123; console.log(res.data); self.setData(&#123; list: list.concat(res.data), currPage: currPage + 1 &#125;); // 处理完成后，终止下拉刷新 wx.stopPullDownRefresh(); &#125; &#125;); &#125;&#125;);","tags":[{"name":"小程序","slug":"小程序","permalink":"https://wencaizhang.gitee.io/tags/小程序/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"小程序","slug":"oh-my-article/小程序","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/小程序/"}]},{"title":"小程序列表页的上拉加载","date":"2018-10-06T07:43:23.000Z","path":"wiki/oh-my-article/小程序/小程序列表页的上拉加载/","text":"上拉刷新，我们可以使用 onReachBottom() 方法，小程序文档是这么说的： 监听用户上拉触底事件。 可以在 app.json 的 window 选项中或页面配置中设置触发距离 onReachBottomDistance。 在触发距离内滑动期间，本事件只会被触发一次。 代码实例： 123456789101112131415161718192021222324252627282930313233343536Page(&#123; data: &#123; pageSize: 10, currPage: 0, list: [] &#125;, onLoad () &#123; this.fetchData(); &#125;, onReachBottom () &#123; this.fetchData(); &#125;, fetchData () &#123; // 这个方法用于请求数据 const self = this; const &#123; pageSize, currPage, list &#125; = this.data; wx.request(&#123; url: 'test.php', // 仅为示例，并非真实的接口地址 data: &#123; pageSize, currPage: currPage + 1, &#125;, success(res) &#123; console.log(res.list) self.setData(&#123; list: list.concat(res.list), currPage: currPage + 1 &#125;) &#125; &#125;) &#125;&#125;)","tags":[{"name":"小程序","slug":"小程序","permalink":"https://wencaizhang.gitee.io/tags/小程序/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"小程序","slug":"oh-my-article/小程序","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/小程序/"}]},{"title":"小程序的传参方案","date":"2018-10-06T07:43:23.000Z","path":"wiki/oh-my-article/小程序/小程序的传参方案/","text":"一、点击事件传参1. 通过 data-* 属性指定参数1&lt;view class=\"block\" bindtap=\"playTap\" data-id=\"&#123;&#123;modle.id&#125;&#125;\"&gt; 2. 通过事件对象 e 获取参数1234playTap (e) &#123; const dataset = e.currentTarget.dataset; console.log(dataset.id)&#125; 二、页面跳转传参小程序页面和普通的 html 相似，都可以通过查询字符串（例如 ?a=1&amp;b=2 的形式）传递参数。 1. 通过查询字符串传参还是上面的例子，获取到 id 之后，跳转到新页面并将 id 传递到新页面，那么就可以这么写： 1234567playTap (e) &#123; const dataset = e.currentTarget.dataset; console.log(dataset.id); wx.navigateTo(&#123; url: '../play/index/?id=' + dataset.id &#125;)&#125; 2. 在生命周期函数 onLoad 中获取参数：123onLoad (options) &#123; console.log(options)&#125;","tags":[{"name":"小程序","slug":"小程序","permalink":"https://wencaizhang.gitee.io/tags/小程序/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"小程序","slug":"oh-my-article/小程序","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/小程序/"}]},{"title":"网络请求接口-fetch","date":"2018-09-30T11:30:13.000Z","path":"wiki/oh-my-article/js/2018-09/fetch-api-md/","text":"fetch 简介最简单的 fetch 请求如下 1234567fetch('http://example.com/movies.json') .then(function(resp) &#123; return resp.json(); &#125;) .then(function(data) &#123; console.log(data); &#125;); fetch 请求 封装1 GET 请求123getData (url) &#123; return fetch(url)&#125; 2 POST 请求以 form-data 形式提交数据 123456789postData (url, payload) &#123; return fetch(url, &#123; method: 'POST', body: JSON.stringify(payload), headers: new Headers(&#123; 'Content-Type': 'application/x-www-form-urlencoded' &#125;) &#125;)&#125; 以 json 形式提交数据123456789postJSON (url, payload) &#123; return fetch(url, &#123; method: 'POST', body: JSON.stringify(payload), headers: new Headers(&#123; 'Content-Type': 'application/json' &#125;) &#125;)&#125; 应用example 12345678910111213let url = 'http://example.com/api/goods_list/'const data = &#123;&#125;postJSON(url, data).then(resp =&gt; resp.json()).then(data =&gt; &#123; console.log(data)&#125;).catch(err =&gt; &#123; console.log(err)&#125;) example2 123456789101112131415161718192021async fn () &#123; let url = 'http://example.com/api/goods_list/' const data = &#123; &#125; try &#123; const resp = await postJSON(url, data) const data = await resp.json() // 下面开始对返回的数据进行处理 if (resp.status == 200) &#123; console.log('success') &#125; else &#123; console.log() &#125; &#125; catch (err) &#123; console.log(err) &#125;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"https://wencaizhang.gitee.io/tags/javascript/"},{"name":"fetch","slug":"fetch","permalink":"https://wencaizhang.gitee.io/tags/fetch/"},{"name":"ajax","slug":"ajax","permalink":"https://wencaizhang.gitee.io/tags/ajax/"},{"name":"react-native","slug":"react-native","permalink":"https://wencaizhang.gitee.io/tags/react-native/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"js","slug":"oh-my-article/js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/"},{"name":"2018-09","slug":"oh-my-article/js/2018-09","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/2018-09/"}]},{"title":"JavaScript 连续赋值","date":"2018-05-22T10:41:00.000Z","path":"wiki/oh-my-article/todoxxx/JavaScript-continuous-assignment-operator/","text":"题目：下面代码的打印结果是什么123var a = &#123; n: 1 &#125;;a.x = a = &#123; n: 2 &#125;;console.log(a.x); 理解：先啰嗦两句基本知识： 符号 = 不叫“等于号 ”，这是赋值操作，代码从右往左执行，如 x = 10; 就读作“把 10 赋值给变量 x“ 如果一个变量的数据类型是对象，那么这个变量存储的仅仅是这个对象在堆内存中的地址。 正文开始： 第一行代码：首先在堆内存中创建一个对象 { n: 1 }，然后在栈内存中创建一个变量 a ，a 储存的值实际上是对象 { n: 1 } 的内存地址，我们假设为 @n1（实际内存地址使用 4 位 16 进制表示）。 第二行代码：. 表示字段访问，其优先级最高。因此首先给变量 a 增加属性 x，属性 x 在未赋值时是 undefined，然后在堆内存中创建一个对象 { n: 2 }，假设其内存地址为 @n2（如下图）。 先将这个内存地址 @n2 赋值给变量 a，然后将这个内存地址赋值给 a.x，但此时这个 a.x 指代的是内存地址为 @n1 的对象的属性 x。 第三行代码：打印 a.x，由于已经将内存地址为 @n2 赋值给了变量 a，并不存在属性 x ，因此打印结果是 undefined 。 易错点这个问题关键点在于第二行连续赋值操作中，先操作了 . 运算符拿到了 a.x 的地址，即 @n1 对象的属性 x，然后改变了 a 保存的引用地址（由 @n1 改为 @n2）。 但是 a.x 已经优先计算出了地址，所以并没有受到影响，因此最后将内存地址 @n2 赋值给了 a.x （即 @n1 对象的属性 x )。 如果将代码稍做修改，也许更容易理解：1234var a = &#123; n: 1 &#125;;var b = a;a.x = a = &#123; n: 2 &#125;;console.log(b); 这一次，我们关注 @n1 的变化，先后将 @n1 这个地址赋值给 a 和 b，最后打印 b ，结果是 { n: 1, x: { n: 2 } }，这就验证了上面的理解。","tags":[{"name":"interview","slug":"interview","permalink":"https://wencaizhang.gitee.io/tags/interview/"},{"name":"javascript","slug":"javascript","permalink":"https://wencaizhang.gitee.io/tags/javascript/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"todoxxx","slug":"oh-my-article/todoxxx","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/todoxxx/"}]},{"title":"「译」从 URL 输入到页面展现发生了什么","date":"2018-05-22T03:26:00.000Z","path":"wiki/oh-my-article/http/what-really-happens-when-you-navigate-to-a-url/","text":"本文翻译自：What really happens when you navigate to a URL 为方便理解，本文采用意译，如有兴趣，可阅读英文原文 步骤： 在浏览器中输入网址 浏览器查找域名对应的 IP 地址 浏览器向服务器发送 HTTP 请求 服务器响应并进行重定向 浏览器向真正的服务器重新发送 HTTP 请求 服务器处理 HTTP 请求 服务器响应请求，返回 HTML 页面 浏览器渲染 HTML 页面 浏览器请求静态资源，如 css 文件、图片、js 文件 浏览器发送异步请求 作为软件开发者，你肯定对 web 应用如何工作以及它工作过程中包含的技术（浏览器、HTML、web server、request handlers 等等）都有一个高水平的认知。 这篇文章中，我们会对当你访问一个 URL 时发生的一系列事情进行深入研究。 1. 在浏览器中输入网址输入网址 facebook.com，故事从这里开始： 2. 浏览器查找域名对应的 IP 地址 访问一个 URL 的第一步就是得到域名对应的 IP 地址，DNS（Domain Name System，域名系统，万维网上作为域名和IP地址相互映射的一个分布式数据库）查找顺序如下： 浏览器缓存（Browser cache） 系统缓存（OS cache） 路由器缓存（Router cache） ISP DNS 缓存（ISP DNS cache） 递归查找（Recursive search） 这里有一个图来描述 DNS 递归查找的过程 关于 DNS 有件值得担心的事是整个域名像是 wikipedia.org 或者 facebook.com 看起来像是仅仅映射到单一的一个 IP 地址。幸运的是，这里有一些缓解瓶颈的方法： Round-robin DNS(轮询调度 DNS)是 DNS 查询结果为多个 IP 地址而不是仅仅一个 IP 地址的解决方案。例如它就解决了 facebook.com 实际上对应着四个 IP 地址的问题。 Load-balancer (负载均衡)是通过硬件监听指定 IP 地址并且将请求转发到其他服务器。大型网站是使用昂贵的高性能负载均衡器的典型例子。 Geographic DNS (地理域名系统)通过映射一个域名到不同的 IP 地址的方式提升了可扩展性，这种方法依赖于客户端的地理位置。 Anycast (任播)是将一个 IP 地址映射到多个物理服务器的路由技术。不幸的是，任播并不适合 TCP 协议，因此在这种情况下几乎不会使用它。 绝大部分 DNS 服务器本身使用任播协议来实现 DNS 的高可用性和低延迟性。 任播(anycast): 是一种网络寻址和路由的策略，使得资料可以根据路由拓朴来决定送到“最近”或“最好”的目的地。 3. 浏览器向服务器发送 HTTP 请求 我们可以非常确定 Facebook 的主页没有被缓存到浏览器中，因为动态页面很快会过期甚至立即过期（把过期时间设置为过去某一时间点）。 所以，浏览器会将请求发送到 Facebook 的服务器。 1234567GET http://facebook.com/ HTTP/1.1Accept: application/x-ms-application, image/jpeg, application/xaml+xml, [...]User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; [...]Accept-Encoding: gzip, deflateConnection: Keep-AliveHost: facebook.comCookie: datr=1265876274-[...]; locale=en_US; lsd=WW[...]; c_user=2101[...] GET 请求说明这个 URL 是用来获取的 http://facebook.com 这个页面的 ，浏览器通过 header 中的 User-Agent 来标识自己（用户使用的操作系统及版本，浏览器及版本等等），通过 Accept 和 Accept-Encoding 规定接收哪种类型的响应信息。header 头 Connection 则要求服务器保持 TCP 连接保持连接状态以便于进一步请求。 另外，这个请求还携带了浏览器在这个域名下的 cookie。你可能已经知道，cookie 是在不同页面中记录网站网站状态的键值对。也就是说，cookie 储存着登录用户的用户名、服务器分配给用户的密码、用户的一些设置等等。cookie 会被储存在客户端的一个文本文件中，每次请求都会一起发送给服务器端。 你可以通过很多工具去查看原生 HTTP 请求和对应的响应信息。我最喜欢的工具是 fiddler，但是仍然有很多别的工具（例如：Firebug），这些工具会给你很大的帮助当你优化一个网站的时候。 除了 GET 请求，另外你非常熟悉的另外一种类型的请求是 POST 请求，经常被用作表单提交。GET 请求通过它的 url 发送参数（例如：http://robozzle.com/puzzle.aspx?id=85）,而 POST 请求在 request body 中（就在 request header 下面）发送参数。 在 URL http://facebook.com/ 中，末尾的 / 是非常重要的。在这个例子中，浏览器可以很安全地在末尾增加 / 。而对于 URL http://example.com/folderOrFile，浏览器就不能自动增加一个 / ，因为浏览器不清楚 folderOrFile 是一个目录还是一个文件。在这种情况下，浏览器将会以不带 / 的形式访问这个 URL ，服务端将会返回一个重定向的响应信息，这就导致了一个不必要的请求和响应。 4. The facebook server responds with a permanent redirect服务器响应并进行重定向 这是 Facebook 服务端针对浏览器请求返回的响应信息。 12345678910111213HTTP/1.1 301 Moved PermanentlyCache-Control: private, no-store, no-cache, must-revalidate, post-check=0, pre-check=0Expires: Sat, 01 Jan 2000 00:00:00 GMTLocation: http://www.facebook.com/P3P: CP=&quot;DSP LAW&quot;Pragma: no-cacheSet-Cookie: made_write_conn=deleted; expires=Thu, 12-Feb-2009 05:09:50 GMT; path=/; domain=.facebook.com; httponlyContent-Type: text/html; charset=utf-8X-Cnection: closeDate: Fri, 12 Feb 2010 05:09:51 GMTContent-Length: 0 服务端通过响应一个永久性转移的 HTTP 状态码来告诉浏览器去访问 http://www.facebook.com/ 而不是 http://facebook.com/ 。 关于服务端一定要将 http://facebook.com/ 重定向到 http://www.facebook.com/ ，而不是立即将用户希望看到的页面返回到浏览器，这里有一些有趣的原因。 其中一个原因和搜索引擎排名有关。如有同一个页面有两个 URL，例如 http://www.igoro.com/ 和http://igoro.com/，搜索引擎可能会认为它们是两个不同的网站，每个 URL 的访问量都低于它们的总和就导致较低的排名。搜索引擎理解永久性转移（301），而且会将两个 URL 的点击量合并成一个单独的排名。 同样的，相同内容对应多个 URL 是不利于缓存的。当一个内容拥有多个名字的时候，它将有可能被缓存多次。 5. The browser follows the redirect浏览器向真正的服务器重新发送 HTTP 请求 浏览器现在知道 http://www.facebook.com/ 才是应该访问的正确地址，因此它发送了另外一个 GET 请求 12345678GET http://www.facebook.com/ HTTP/1.1Accept: application/x-ms-application, image/jpeg, application/xaml+xml, [...]Accept-Language: en-USUser-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; [...]Accept-Encoding: gzip, deflateConnection: Keep-AliveCookie: lsd=XW[...]; c_user=21[...]; x-referer=[...]Host: www.facebook.com header 头的信息和第一次请求相同。 6. The server ‘handles’ the request服务器处理 HTTP 请求 服务端将会接收到 GET 请求，然后加工处理并且返回一个响应信息。 这看起来像是一个简单的任务，但实际上这里发生了很多有趣的事情 —— 即使是一个像我的博客这样简单的网站也是如此，更不用说像 Facebook 这样大规模可扩展的网站了。 Web server softwareweb 服务器（如 IIS 或者 Apache）接收到 HTTP 请求然后决定运行哪一个请求处理程序去处理这个请求。一个请求处理程序（由 ASP、.NET、PHP、Ruby 等构建）是一个读取请求和生成 HTML 响应的程序。 在这个简单的例子中，请求处理程序可以被储存在一个文件中xxx，例如 http://example.com/folder1/page1.aspx 这个 URL 会被映射到 /httpdocs/folder1/page1.aspx 这个文件。web 服务器同样也可以被配置，这样便于手工指定请求处理函数，因此文件 page1.aspx 对应的公开 URL 可以是 http://example.com/folder1/page1。 每一个动态网站都面临一个有意思的难题就是如何储存数据。小型网站通常会有一个 SQL 数据库去储存他们的数据，但是那些储存庞大数据或者拥有很多访客甚至两者兼具的网站，就必须找到一个方法通过多个服务器去将数据分割开。 Request handler请求处理程序读取请求，以及请求的参数和 cookie 。随后它会读取并且有可能更新一些存储在服务端的数据。然后，程序会生成 HTML 响应 7. The server sends back a HTML response服务器响应请求，返回 HTML 页面 下面是服务端生成并返回的响应信息： 1234567891011121314HTTP/1.1 200 OKCache-Control: private, no-store, no-cache, must-revalidate, post-check=0, pre-check=0Expires: Sat, 01 Jan 2000 00:00:00 GMTP3P: CP=&quot;DSP LAW&quot;Pragma: no-cacheContent-Encoding: gzipContent-Type: text/html; charset=utf-8X-Cnection: closeTransfer-Encoding: chunkedDate: Fri, 12 Feb 2010 09:05:55 GMT 2b3��������T�n�@����[...] 响应信息数据大小为 36kb ，xxxxx header 中字段 Content-Encoding 12345678&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\" id=\"facebook\" class=\" no_js\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-type\" content=\"text/html; charset=utf-8\" /&gt;&lt;meta http-equiv=\"Content-language\" content=\"en\" /&gt;... 除了压缩之外，header 头指定了是否缓存以及如何缓存这个页面，xxx cookie ，隐私信息，等等 注意这里的 header 头中 Content-Type 被设置为 text/html 。header 告知浏览器将响应内容（response content）当做 HTML 渲染，而不是文件进行下载。浏览器将会通过 header 去决定如何解释相应信息，但是也会参考其他因素，比如 URL 扩展内容。 8. The browser begins rendering the HTML浏览器渲染 HTML 页面 在浏览器接受全部的 HTML 文档信息之前，它就已经开始渲染网站了。 9. The browser sends requests for objects embedded in HTML浏览器请求静态资源，如 css 文件、图片、js 文件 10. The browser sends further asynchronous (AJAX) requests浏览器发送异步请求 在 Web 2.0 时代，即使在页面渲染完毕，客户端也还是同服务端保持通信。 例如，Facebook 聊天功能会保持更新你的朋友列表当他们进来或者离开。为了更新你的在记录中的朋友列表，你的浏览器中的 JavaScript 必须向服务端发送一个异步请求。这个异步请求时一个程序化构造的 GET 或者 POST 请求通过一个特殊的 URL。在 Facebook 这个例子中，客户端发送一个 POST 请求指向 http://www.facebook.com/ajax/chat/buddy_list.php ，它去获取一个关于你有哪些朋友在线的列表。 这个模式有时叫做 AJAX ，代表着 Asynchronous JavaScript And XML，但即使这样也没有一个特殊的理由要求服务端必须把响应格式化为 XML 格式。例如，Facebook 在异步请求响应中返回 JavaScript 代码段。 通过 fiddler 可以查看浏览器发出的异步请求。事实上，你不仅可以被动地观察这些请求，你利用 fiddler 同样也可以修改和发送请求。 Facebook chat 提供了一个关于 AJAX 的有趣问题的一个例子：将数据从服务器推送到客户端。因为 HTTP 是一个请求-响应模式的协议，所以服务器不能向客户端发送新的消息。相反，客户端必须每隔几秒钟得到服务端的响应以便于查看是否有新的消息到达。 长轮询是一个有趣的技巧，它可以减少 小结关于 web 网站中各个部分如何协同工作，希望本文能对你有所启发。","tags":[{"name":"interview","slug":"interview","permalink":"https://wencaizhang.gitee.io/tags/interview/"},{"name":"http","slug":"http","permalink":"https://wencaizhang.gitee.io/tags/http/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"http","slug":"oh-my-article/http","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/http/"}]},{"title":"hexo 基本使用备忘","date":"2018-05-18T12:35:00.000Z","path":"wiki/oh-my-article/blog/hexo-basic-usage/","text":"简介 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装全局安装 hexo 脚手架：1npm install -g hexo-cli 创建博客在 blog 目录下新建一个网站，然后安装 npm 依赖： 123hexo init blogcd blognpm install 常用命令 生成静态网站 1hexo generate 启动服务器 1hexo server 清除缓存文件 (db.json) 和已生成的静态文件 (public) 1hexo clean 新建一篇文章 1hexo new [layout] &lt;title&gt; 小Tips在 package.json 中自定义 npm scripts 脚本：1234\"scripts\": &#123; \"dev\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\", \"build\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo d\"&#125; Hexo 文档","tags":[{"name":"hexo","slug":"hexo","permalink":"https://wencaizhang.gitee.io/tags/hexo/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"blog","slug":"oh-my-article/blog","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/blog/"}]},{"title":"hexo-admin: hexo博客的后台管理工具","date":"2018-05-18T10:01:00.000Z","path":"wiki/oh-my-article/blog/hexo-admin-hexo-background-manage-tool/","text":"零、前言 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Hexo 生成静态网站，我们可以很灵活的将其部署在 GitHub Pages 上或者是随便一个静态服务器上。 但随之带来的一个问题就是无法像 wordpress 一样提供一个后台管理界面。hexo-admin 很好的解决了这一痛点需求。 一、安装1. 安装 hexo 并创建 blog如已创建则跳过此步骤 12345npm install -g hexocd ~/hexo init my-blogcd my-blognpm install 2. 安装 hexo-admin 并启动服务12npm install --save hexo-adminhexo server -d hexo-admin 管理界面路径为 博客预览地址 + admin，即如果你的博客预览地址为 http://localhost:4000/ ，则 hexo-admin 管理界面路径为 http://localhost:4000/admin/ 二、启用密码保护启动 hexo 预览服务之后，进入 http://localhost:4000/admin/ 即可直接对博客文章进行修改，也就是说如果你的博客安装在静态服务器上，则别人也有可能通过这个地址，对你的博客进行修改，为了避免这一情况，可以启动密码保护服务。步骤如下： 启动 hexo 服务，打开 hexo-admin 界面，找到 Settings &gt; Setup authentification，如图所示： 点击进入设置页面，在页面中分别填写 Username, Password 和 Secret，填写完成之后，页面下方会生成一段配置代码。配置代码示例： 12345# hexo-admin authentificationadmin: username: username password_hash: $2a$10$sTyd76sSKai3FGnSYgi4cO6ibhFaJDMbTXx3dja7SRPh1m1hXN8za secret: secret 将这段代码复制到根目录配置文件 _config.yml 中，然后重启 hexo 服务，再次进入 hexo-admin 界面时就需要使用前面设置的用户名和密码进行登录了。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://wencaizhang.gitee.io/tags/hexo/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"blog","slug":"oh-my-article/blog","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/blog/"}]},{"title":"JavaScript 序列化与反序列化","date":"2018-03-02T02:51:00.000Z","path":"wiki/oh-my-article/js/serialize-and-unserialize-of-javascript/","text":"一、$.param()param() 方法创建数组或对象的序列化表示。该序列化值可在进行 AJAX 请求时在 URL 查询字符串中使用。 1. 使用示例示例一：序列化目标是对象 123456// 假设已经引入 jquery.jsvar obj = &#123; username: 'zwc' , age: 18 &#125;;var querystring = $.param(obj);console.log(querystring);// \"username=zwc&amp;age=18\" 示例二：序列化目标数据结构深层嵌套 123456789101112131415161718// 假设已经引入 jquery.jsvar myObject = &#123; a: &#123; one: 1, two: 2, three: 3 &#125;, b: [1,2,3]&#125;;var recursiveEncoded = $.param(myObject);var recursiveDecoded = decodeURIComponent($.param(myObject));console.log(recursiveEncoded);// \"a%5Bone%5D=1&amp;a%5Btwo%5D=2&amp;a%5Bthree%5D=3&amp;b%5B%5D=1&amp;b%5B%5D=2&amp;b%5B%5D=3\"console.log(recursiveDecoded);// \"a[one]=1&amp;a[two]=2&amp;a[three]=3&amp;b[]=1&amp;b[]=2&amp;b[]=3\" 示例三：序列化目标是数组 123456789// 假设已经引入 jquery.jsvar arr = [ &#123; name: 'username', value: 'zwc' &#125;, &#123; name: 'age', value: 18 &#125;];var querystring = $.param(arr);console.log(querystring);// \"username=zwc&amp;age=18\" 2. 模拟 $.param()根据 使用示例 模拟出代码的实现过程。暂时先不考虑边界值，即方法调用时传入的都是合法参数（参照示例中的参数）。 i 第一版针对 使用示例 中示例一进行模拟 // 方法定义12345678910111213function param() &#123; var target = arguments[0]; var str = ''; if (!target) return ''; if (target instanceof Object) &#123; for (key in target) &#123; if (target.hasOwnProperty(key)) &#123; str += key + '=' + target[key]; &#125; &#125; return str; &#125;&#125; // 测试代码1234var obj = &#123; username: 'zwc' , age: 18 &#125;;var querystring = param(obj);console.log(querystring);// \"username=zwcage=18\" ii 第二版针对 使用示例 中示例一进行模拟 // 方法定义1234567891011121314151617181920212223242526272829function param() &#123; var target = arguments[0]; var str = ''; if (!target) return str; if (target instanceof Object) &#123; for (key in target) &#123; if (target.hasOwnProperty(key)) &#123; if (target[key] instanceof Object) &#123; var tmp = target[key]; for (k in tmp) &#123; str += key + '[' + k +']=' + tmp[k]; &#125; &#125; else if (target[key] instanceof Array) &#123; var tmp = target[key]; for (var i = 0; i &lt; tmp.length; i++) &#123; str += key + '[]=' + tmp[i]; &#125; &#125; else &#123; str += key + '=' + target[key]; &#125; &#125; &#125; return str; &#125; else if (target instanceof Array) &#123; &#125; else &#123; &#125;&#125; // 测试代码12 iii 第三版这一次把更复杂的情况考虑进去，也就是递归。 // 方法定义12345678910111213141516171819202122232425262728function param() &#123; var target = arguments[0]; var str = ''; if (!target) return str; if (target instanceof Object) &#123; for (key in target) &#123; var value = target[key]; if (value instanceof Object || value instanceof Array) &#123; paramObj(key, value); &#125; else &#123; str += '&amp;' + key + '=' + value; &#125; &#125; &#125; function paramObj (key, value) &#123; for (k in value) &#123; var temp = value[k]; var tempKey = value instanceof Object ? key + '[' + k +']' : key + '[]'; if (temp instanceof Object || temp instanceof Array) &#123; paramObj(tempKey, temp) &#125; else &#123; str += '&amp;' + tempKey + '=' + temp; &#125; &#125; &#125; return encodeURIComponent(str.slice(1));&#125; // 测试代码12345678910111213141516var myObject = &#123; a: &#123; one: 1, two: 2, three: &#123; name: 'jack', age: 18 &#125; &#125;, b: [1,2,3]&#125;;var recursiveEncoded = param(myObject);var recursiveDecoded = decodeURIComponent(param(myObject));console.log(recursiveEncoded);// a%5Bone%5D%3D1%26a%5Btwo%5D%3D2%26a%5Bthree%5D%5Bname%5D%3Djack%26a%5Bthree%5D%5Bage%5D%3D18%26b%5B0%5D%3D1%26b%5B1%5D%3D2%26b%5B2%5D%3D3console.log(recursiveDecoded);// \"a[one]=1&amp;a[two]=2&amp;a[three]=3&amp;b[]=1&amp;b[]=2&amp;b[]=3\" 二、$.serializeArray()三、$.serialize()","tags":[{"name":"javascript","slug":"javascript","permalink":"https://wencaizhang.gitee.io/tags/javascript/"},{"name":"jQuery","slug":"jQuery","permalink":"https://wencaizhang.gitee.io/tags/jQuery/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"js","slug":"oh-my-article/js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/"}]},{"title":"调教你的Xshell","date":"2018-01-17T15:05:00.000Z","path":"wiki/oh-my-article/tool/config-your-xshell/","text":"Xshellxshell是一款知名终端模拟软件，个人用户免费，中文界面，方便好用。 但是一些默认设置需要手动调整之后才更顺手更好用。 打开选项窗口如图所示：工具 -&gt; 选项即可打开选项窗口 将选中的文本自动复制到剪贴板（左键选中自动复制）如图所示，在“键盘和鼠标”选项卡中勾选对应选项即可： 右键设置如图所示，设置右键和中键的功能，其中下拉选项的含义如下： 选项 蹩脚翻译 Do nothing 什么都不做 Open the popup menu 打开弹出式菜单 Paste the clipboard contents 粘贴剪切板的内容 Open Properties dialog 打开属性窗口 Send carriage return 发送回车 Paste the selected text 粘贴被选中的文本 我的选择是，中键打开弹出式菜单，右键粘贴剪切板的内容 Ctrl + C 复制Ctrl + C 常用于结束正在进行中的命令，另外在设置了左键选中自动复制之后，也就不需要再额外设置复制的快捷键了。 Ctrl + V 粘贴 键盘和鼠标选项卡 -&gt; 编辑按钮 新建按钮 同时按下 Ctrl 和 V 会自动进入编辑面板 类型 选择菜单，操作选择 [编辑] 粘贴 最后点击确定即可 设置字体大小和配色方案 文件 -&gt; 属性，或者使用快捷键 Alt + P 打开属性窗口 点击左测外观，然后在右侧进行设置 最后点击确定即可","tags":[{"name":"linux","slug":"linux","permalink":"https://wencaizhang.gitee.io/tags/linux/"},{"name":"tool","slug":"tool","permalink":"https://wencaizhang.gitee.io/tags/tool/"},{"name":"xshell","slug":"xshell","permalink":"https://wencaizhang.gitee.io/tags/xshell/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"tool","slug":"oh-my-article/tool","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/tool/"}]},{"title":"小tips-使用正则获取查询字符串参数","date":"2018-01-17T13:39:00.000Z","path":"wiki/oh-my-article/js/parse-querystring/","text":"一、什么是查询字符串大部分开发者都应当对“查询字符串”不陌生，它随处可见。 例如，当我们用百度搜索关键字 regexp 时，地址栏中 ? 后面的字符串就叫查询字符串。 也就是说，https://www.baidu.com/s?ie=UTF-8&amp;wd=regexp 中的 ie=UTF-8&amp;wd=regexp 就是查询字符串。 使用查询字符串的场景随处可见，如上面的网页地址中的查询字符串，还有 HTTP 协议中的 GET 请求也是将参数拼接成查询字符串的形式。 二、解析查询字符串前端开发过程中，通过查询字符串传递参数是一个常见的场景。那么就需要这么一个操作查询字符串的处理：从 url 中获取查询字符串，然后将查询字符串解析成方便处理的 json 对象。 获取查询字符串并打印： 12345// 假设此时的 URL 是：https://www.baidu.com/s?ie=UTF-8&amp;wd=regexpvar querystring = window.location.search.slice(1);console.log(querystring); // \"ie=UTF-8&amp;wd=regexp\" location 挂载在全局对象 window 上，其属性 search 指的是 URL 中问号 ? 之后的部分（包含 ?），即 ?ie=UTF-8&amp;wd=regexp，通过 String.prototype.slice() 提取其中除 ? 之外所有内容，即可得到查询字符串。 下面是将查询字符串解析成 json 对象的几种思路。 方法一：split 通过 split 方法，指定 &amp; 为分隔符，得到处理后的数组 [&quot;ie=UTF-8&quot;, &quot;wd=regexp&quot;] 遍历数组，同样通过 split 方法，指定 = 为分隔符，得到 [&quot;ie&quot;, &quot;UTF-8&quot;] 和 [&quot;wd&quot;, &quot;regexp&quot;] 遍历获取的数组中第一项则为键，第二项为对应的值，赋值给 json 123456789101112131415161718var querystring = window.location.search.slice(1); // \"ie=UTF-8&amp;wd=regexp\"var json = parse(querystring);console.log(json);// &#123;ie: \"UTF-8\", wd: \"regexp\"&#125;function parse (querystring) &#123; var querystring = querystring || ''; var queryArray = querystring.split('&amp;'); // [\"ie=UTF-8\", \"wd=regexp\"] var json = &#123;&#125;; queryArray.forEach(function (item, index) &#123; var tmp = item.split('='); // [\"ie\", \"UTF-8\"] // [\"wd\", \"regexp\"] json[tmp[0]] = tmp[1]; &#125;) return json&#125; 方法二：replace + regexp先上代码：12345678910111213var querystring = window.location.search.slice(1);parse(querystring);function parse (querystring) &#123; var querystring = querystring || ''; var reg = /([^=&amp;]+)=([^=&amp;]*)/ig; var json = &#123;&#125;; querystring.replace(reg, function (match, $1, $2) &#123; json[$1] = $2 &#125;) return json;&#125; 利用字符串的 replace 方法，如果第一个参数是正则表达式， 并且其为全局匹配模式，同时第二个参数是一个函数，那么每次匹配到的时候，这个函数都会被调用。 正则 /([^=&amp;]+)=([^=&amp;]*)/ig 的含义为，使用 = 连接，且 = 前后的字符串都不能以 = 或者 &amp; 开头。 function 参数含义： 匹配字符串 正则表达式分组内容，没有分组则没有该参数 匹配项在字符串中的 index 原字符串 match $1 $2 index origin 第一次 ie=UTF-8 ie UTF-8 0 ie=UTF-8&amp;wd=regexp 第二次 wd=regexp wd regexp 9 ie=UTF-8&amp;wd=regexp 正则表达式的含义 String.prototype.split() · MDN String.prototype.slice() · MDN String.prototype.replace() · MDN","tags":[{"name":"javascript","slug":"javascript","permalink":"https://wencaizhang.gitee.io/tags/javascript/"},{"name":"querystring","slug":"querystring","permalink":"https://wencaizhang.gitee.io/tags/querystring/"},{"name":"regexp","slug":"regexp","permalink":"https://wencaizhang.gitee.io/tags/regexp/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"js","slug":"oh-my-article/js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/"}]},{"title":"小tips - iframe 高度自适应","date":"2018-01-17T13:39:00.000Z","path":"wiki/oh-my-article/js/iframe-height-auto/","text":"背景iframe 有两大烦人的东西，一是 iframe 高度问题，二是带遮罩的弹框提示。这两个问题都没什么处理经验，于是花点时间研究，基本实现了效果，于是记录下来以便备忘。 本文为高度自适应问题的解决方案。 实现此方法前提条件：为方便获取 iframe 元素，需要知道该 iframe 的 id（当页面只有一个 iframe 元素时，使用类名或标签名也可以）。 此处假设 iframe 元素的 id 为 iframe。 为行文方便，后面将 iframe 元素指定的页面称为“子窗口或子页面”， iframe 元素所在的页面称为“父窗口” jQuery 版123function resizeIframeParentHeight() &#123; $(\"#iframe\", window.parent.document).css('height', $('body').outerHeight());&#125; 此方法在子窗口中，在初次加载完成或者页面高度发生变化时执行 $(&quot;#iframe&quot;, window.parent.document) 获取父窗口中的 iframe 元素 $(&#39;body&#39;).outerHeight() 获取 iframe 元素指定页面的高度 js 版您可以狠狠点击这里：js版iframe高度自适应demo 12345function resizeIframeParentHeight() &#123; var iframeHeight = document.body.scrollHeight; var iframe = window.parent.document.getElementById('iframe'); iframe.style.height = iframeHeight + 'px';&#125; 此方法在子窗口中，在初次加载完成或者页面高度发生变化时执行 window.parent 获取父窗口中 document ，则 window.parent.document.getElementById(&#39;iframe&#39;) 获取 iframe 元素 document.body.scrollHeight 获取 iframe 元素指定页面的高度","tags":[{"name":"javascript","slug":"javascript","permalink":"https://wencaizhang.gitee.io/tags/javascript/"},{"name":"iframe","slug":"iframe","permalink":"https://wencaizhang.gitee.io/tags/iframe/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"js","slug":"oh-my-article/js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/"}]},{"title":"小tips - 利用 localStorage 记住用户名和密码","date":"2018-01-16T09:35:00.000Z","path":"wiki/oh-my-article/js/remember-password-by-localStorage/","text":"一、问题背景对于一个登录页面，通常都要支持的一个功能是记住密码，这样下次打开时就不需要重新输入，可以很好的提高用户体验。 在对比了 cookie 和 localStorage 之后，我选择了 localStorage 用于存储用户登录信息。 cookie 所有浏览器都支持，无兼容问题 大小限制：4k 左右 可设置失效时间 cookie 会被附加到每个 HTTP 请求中 localStorage: IE8+ （现在项目也基本都不要求兼容 IE6~7 了，因此可以放心使用） 大小限制：一般 5MB 仅在客户端中保存，不参与和服务器的通信 需手动清除，否则永远有效 sessionStorage 和 localStorage 基本只有一点不同：sessionStorage 是基于会话的，页面关闭或浏览器关闭后失效 二、demo 展示实际的登录页面可能还需要注册，所以就单独做了一个高保真的 demo 页面。 您可以狠狠地点击这里：HTML5 localstorage本地存储应用demo 进入 demo 页面，您可以看到两个输入框和一个登录按钮。 您可以随心所欲的输入一个狂拽炫酷的用户名和密码，然后点击登录按钮，由于此 demo 仅用于展示记录密码功能，因此页面并无任何提示或跳转。 在真实的场景中，点击按钮时应验证用户名密码，验证通过之后自动跳转到网站其他页面，与本文主题无关，故不做展示 点击登录按钮之后，刷新页面，输入框已经自动填充刷新之前点击按钮时对应的值。 三、localStorage 提供的方法此处只是简单介绍，详细使用请看这里 1. 设置值 用来创建新数据项和更新已存在的值 接受两个参数——要创建/修改的数据项的键，和对应的值1window.localStorage.setItem(key, value); 2. 获取值 获取一个数据项 接受数据项的键作为参数，并返回数据值1window.localStorage.getItem(key); 3. 删除值 接受一个参数——你想要移除的数据项的键，然后会将对应的数据项从域名对应的存储对象中移除1window.localStorage.removeItem(key); 4. 清空域名对应的整个存储对象 不接受参数，只是简单地清空域名对应的整个存储对象1window.localStorage.clear(); 5. 监听 localStorage 的变化 创建/更新/删除数据项时触发 重复设置相同的键值不会触发该事件 localStorage.clear() 方法至多触发一次该事件12345678window.addEventListener('storage', function(e) &#123; // localStorage 发生改变时，事件对象包含了多个有用的属性信息 console.log(e.key); // 改变的数据项的键 console.log(e.oldValue); // 改变前的旧值 console.log(e.newValue); // 改变后的新值 console.log(e.url); // 改变的存储对象所在的文档的 URL console.log(e.storageArea); // 存储对象本身&#125;); 四、具体实现1. 数据存储每次用户点击一次登录按钮，记录下当前使用的用户名和密码。例如，放到一个对象中，然后存储之，代码如下：12345var userData = &#123; username: '张君宝', pwd: '123456',&#125;window.localStorage.setItem('userData', JSON.stringify(userData)); 2. 数据读取每次页面加载的时候，将相对应的数据读出来。如下：12var userData = window.localStorage.getItem('userData');userData = JSON.parse(userData); 需要注意的是：实际上 localStorage 存储的是字符串，因此存储时需要使用 JSON.stringfy() 将其转化成字符串，获取时使用 JSON.parse() 再将其转化为 JSON 格式。 五、最后localStorage 使用场景远不止于此，例如同源窗口通信，记录用户使用习惯等。 更多阅读： 使用 Web Storage API localStorage 还能这么用","tags":[{"name":"javascript","slug":"javascript","permalink":"https://wencaizhang.gitee.io/tags/javascript/"},{"name":"localStorage","slug":"localStorage","permalink":"https://wencaizhang.gitee.io/tags/localStorage/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"js","slug":"oh-my-article/js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/"}]},{"title":"What is GitHub Pages","date":"2018-01-09T10:30:53.000Z","path":"wiki/oh-my-article/blog/GitHub-Pages/","text":"Github Pages 是 Github 的静态页面托管服务。它设计的初衷是为了用户能够直接通过 Github 仓库来托管用户个人、组织或是项目的专属页面。参考：What is GitHub Pages? 友情提示：使用此功能需要对 git 及 GitHub 有一定了解 GitHub Pages 功能介绍使用步骤： 注册 GitHub 账户 创建一个仓库 打开此仓库的 Settings 页签 找到 GitHub Pages 部分 因为 GitHub Pages 会展示指定位置（分支）的 index.html 或者 README.md，因此 Source 用于指定分支。 Source 字段有 4 个选项： 默认为 None ，即不显示 master branch，本仓库的 master 分支 master branch/docs folder，本仓库的 master 分支下的 docs 目录 gh-pages branch，本仓库的 gh-pages 分支（需创建后才显示此选项） 也就是说，只要把静态站点放到上面三个位置（分支）之一，然后设置正确的 Source 字段，即可使用 GitHub Pages 功能。生成的静态网站地址会友好的显示在 Source 字段上方。 GitHub Pages 使用思路扩展 很多开源项目都会选择将 master branch/docs 用于展示项目使用文档 制作个人兴趣静态网站（如：http://wencaizhang.com/demo) 作为个人静态博客站点（如：http://wencaizhang.com/blog)","tags":[{"name":"other","slug":"other","permalink":"https://wencaizhang.gitee.io/tags/other/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"blog","slug":"oh-my-article/blog","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/blog/"}]},{"title":"What is GitHub Pages","date":"2018-01-09T10:30:53.000Z","path":"wiki/oh-my-article/other/GitHub-Pages/","text":"Github Pages 是 Github 的静态页面托管服务。它设计的初衷是为了用户能够直接通过 Github 仓库来托管用户个人、组织或是项目的专属页面。参考：What is GitHub Pages? 友情提示：使用此功能需要对 git 及 GitHub 有一定了解 GitHub Pages 功能介绍使用步骤： 注册 GitHub 账户 创建一个仓库 打开此仓库的 Settings 页签 找到 GitHub Pages 部分 因为 GitHub Pages 会展示指定位置（分支）的 index.html 或者 README.md，因此 Source 用于指定分支。 Source 字段有 4 个选项： 默认为 None ，即不显示 master branch，本仓库的 master 分支 master branch/docs folder，本仓库的 master 分支下的 docs 目录 gh-pages branch，本仓库的 gh-pages 分支（需创建后才显示此选项） 也就是说，只要把静态站点放到上面三个位置（分支）之一，然后设置正确的 Source 字段，即可使用 GitHub Pages 功能。生成的静态网站地址会友好的显示在 Source 字段上方。 GitHub Pages 使用思路扩展 很多开源项目都会选择将 master branch/docs 用于展示项目使用文档 制作个人兴趣静态网站（如：http://wencaizhang.com/demo) 作为个人静态博客站点（如：http://wencaizhang.com/blog)","tags":[{"name":"other","slug":"other","permalink":"https://wencaizhang.gitee.io/tags/other/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"other","slug":"oh-my-article/other","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/other/"}]},{"title":"hexo 备份","date":"2018-01-07T15:01:00.000Z","path":"wiki/oh-my-article/blog/hexo-source-backup-and-deploy/","text":"搭建博客的思路 使用框架 Hexo 文档 将 markdown 文章解析成静态网页 借助 GitHub Pages 展示静态网页的功能，部署解析出来的静态网页（hexo 备份） 备份源文件的思路 这里写如何备份 markdown 文章源文件，至于详细的搭建步骤请自行百之谷之，不再详述 GitHub Pages 功能可以展示三个位置的静态网页资源： master 分支 master 分支的 docs 目录 gh-pages 分支 那么，不妨利用分支功能另外创建一个 source 分支用于管理备份配置文件和博客文章源文件，如果对博客主题进行了自定义，甚至可以再创建一个 theme 分支用于管理主题。 如此一来，将所有的文件都纳入版本控制系统，无论在哪里都可以快速创建一个相同的博客写作环境 一键部署的思路如果按照上面的方法做，每次预览或部署静态网页显得略微有点麻烦： 预览：删除旧的解析出来的网页（hexo clean），重新解析（hexo g），最后启动本地服务器（hexo s） 部署静态网页：删除旧的解析出来的网页（hexo clean），重新解析（hexo g），最后部署到 GitHub 上（hexo d） 提交源文件至 source 分支 如果修改了主题，还要切换目录并提交主题至 theme 分支 有木有很麻烦啊！ 但是现在，利用 npm scripts 可以一条命令全部搞定！ 做前端开发的同学可能会对此比较熟悉，在网站根目录下有一个 package.json 文件，里面有个 scripts 字段可用于自定义命令。 如果对 npm scripts 不太了解的，推荐：npm scripts 使用指南 · 阮一峰 简单介绍下这段 npm scripts ： scripts 字段是一个对象。它的每一个属性，对应一段脚本。例如 dev 字段对应的脚本是 hexo clean &amp;&amp; hexo g &amp;&amp; hexo s，命令行中使用 npm run dev 就可以执行这段脚本 &amp;&amp;: 表示前一个任务执行成功，后一个任务才执行，&amp; 则是两个任务同时执行 npm run dev: 主要用于本地预览博客，按照顺序执行 hexo clean、hexo g、hexo s，只有前一个任务执行成功，后一个才执行 npm run push: push 资源文件和静态页面资源 npm run prepush: 使用 hexo 将文章解析成静态页面于 public 目录下，然后将 public 目录重命名为 docs npm run postpush: push theme 分支 钩子: npm scripts 有 pre 和 post 两个钩子。例如 push 脚本的钩子是 prepush 和 postpush，prepush 在 push 脚本之前执行，postpush 在 push 脚本之后执行。也就是说，执行 npm run push 的时候，会自动按照顺序先后执行 npm run prepush &amp;&amp; npm run push &amp;&amp; npm run postpush 。 因此，在部署时，只需执行命令 npm run push，会自动部署博客网站，提交 source 和 theme 分支。 123456\"scripts\": &#123; \"dev\": \"hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\", \"prepush\": \"rm -rf docs &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; mv public docs\", \"push\": \"git add -A &amp;&amp; git commit -m publish &amp;&amp; git push origin master\", \"postpush\": \"cd themes/indigo &amp;&amp; git add -A &amp;&amp; git commit -m update &amp;&amp; git push origin theme\"&#125;","tags":[{"name":"hexo","slug":"hexo","permalink":"https://wencaizhang.gitee.io/tags/hexo/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"blog","slug":"oh-my-article/blog","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/blog/"}]},{"title":"正则表达式","date":"2018-01-02T08:27:53.000Z","path":"wiki/oh-my-article/js/old/regexp/","text":"元字符元字符既可以是放在 [] 中的任意单个字符（如 [a] 表示匹配单个小写字符 a ） 也可以是字符序列（如 [a-d] 表示匹配 a 、 b 、 c 、 d 之间的任意一个字符，而 \\w 表示任意英文字母和数字及下划线） 下面是一些常见的元字符： 元字符 含义 . 匹配除 \\n 以外的任何字符（注意元字符是小数点）。 [abcde] 匹配 abcde 之中的任意一个字符 [a-h] 匹配 a 到 h 之间的任意一个字符 [^fgh] 不与 fgh 之中的任意一个字符匹配 \\w 匹配大小写英文字符及数字 0 到 9 之间的任意一个及下划线，相当于 [a-zA-Z0-9_] \\W 不匹配大小写英文字符及数字 0 到 9 之间的任意一个，相当于 [^a-zA-Z0-9_] \\s 匹配任何空白字符，相当于 [ \\f\\n\\r\\t\\v] \\S 匹配任何非空白字符，相当于 [^\\s] \\d 匹配任何 0 到 9 之间的单个数字，相当于 [0-9] \\D 不匹配任何 0 到 9 之间的单个数字，相当于 [^0-9] [\\u4e00-\\u9fa5] 匹配任意单个汉字（这里用的是 Unicode 编码表示汉字的 ) 正则表达式限定符上面的元字符都是针对单个字符匹配的，要想同时匹配多个字符的话，还需要借助限定符。 下面是一些常见的限定符 ( 下表中 n 和 m 都是表示整数，并且 0 &lt; n &lt; m) ： 限定符 含义 * 匹配 0 到多个元字符，相当于 {0,} ? 匹配 0 到 1 个元字符，相当于 {0,1} + 匹配至少 1 个元字符，相当于 {1,} {n} 匹配 n 个元字符 {n,} 匹配至少 n 个元字符 {n,m} 匹配 n 到 m 个元字符 \\b 匹配单词边界 ^ 字符串必须以指定的字符开始 $ 字符串必须以指定的字符结束 其他 由于在正则表达式中\\、?、*、^、$、+、(、)、|、{、[等字符已经具有一定特殊意义，如果需要用它们的原始意义，则应该对它进行转义，例如希望在字符串中至少有一个“ \\ ”，那么正则表达式应该这么写： \\+ 。 可以将多个元字符或者原义文本字符用括号括起来形成一个分组，比如 ^(13)[4-9]\\d{8}$ 表示任意以 13 开头的移动手机号码。 另外对于中文字符的匹配是采用其对应的 Unicode 编码来匹配的，对于单个 Unicode 字符，如 \\u4e00 表示汉字“一”， \\u9fa5 表示汉字“龥”，在 Unicode 编码中这分别是所能表示的汉字的第一个和最后一个的 Unicode 编码，在 Unicode 编码中能表示 20901 个汉字。 关于 \\b 的用法，它代表单词的开始或者结尾，以字符串 123a 345b 456 789d 作为示例字符串，如果正则表达式是 \\b\\d{3}\\b，则仅能匹配 456 。 可以使用 | 来表示或的关系，例如 [z|j|q] 表示匹配 z 、 j 、 q 之中的任意一个字母。 正则验证工具： https://regexper.com/ 正则对象属性 属性均为只读，无法设置其值 属性 含义 默认值 global 是否全文搜索 false ignoreCase 是否大小写敏感 false multiline 多行搜索 false lastIndex 是当前表达式匹配内容的最后一个字符的下一个位置 无 source 正则表达式的文本字符串 无 如下： 123456789101112var reg1 = /\\w/;var reg2 = /\\w/gim;console.log(reg1.global); // falseconsole.log(reg1.ignoreCase); // falseconsole.log(reg1.multiline); // falseconsole.log(reg1.source); // \"\\w\"console.log(reg2.global); // trueconsole.log(reg2.ignoreCase); // trueconsole.log(reg2.multiline); // trueconsole.log(reg2.source); // \"\\w\" 正则对象方法RegExp.prototype.test(str) 用于测试字符串参数中是否存在匹配正则表达式模式的字符串 如果存在则返回 true，否则返回 false 牛刀小试： 12345var reg = /\\w/;reg.test('a'); // truereg.test('ab'); // truereg.test('$'); // true 加上 g 标志后，结果有了一丝不同~~ 12345678var reg = /\\w/g;reg.test('ab'); // truereg.test('ab'); // truereg.test('ab'); // falsereg.test('ab'); // truereg.test('ab'); // truereg.test('ab'); // truereg.test('ab'); // false 这是因为在匹配的时候并不是每次都是从头开始的，而是每次匹配都会从上次匹配结果的下一个位置开始匹配，也就是 lastIndex 属性 第一次匹配到 a， 第二次从 b 开始，匹配到 b 第三次从 b 开始，没有匹配结果 因此出现上面的现象 12345var reg = /\\w/g;while(reg.test('ab')) &#123; console.log(reg.lastIndex);&#125;// 打印结果为 1，2 test() 本意测试字符串和正则能否匹配上，而不关心是在哪个位置匹配到，所以就没必要加上 g 标志。 RegExp.prototype.exec(str) 使用正则表达式对字符串进行搜索，并将更新全局 RegExp 对象的属性以反映匹配结果 如果没有匹配的文本则返回 null，否则返回一个结果数组，数组有两个属性： index 声明匹配文本地第一个字符的位置 input 存放被检索的字符串 string 第一个元素是与正则表达式相匹配的文本 第二个元素是与正则表达式的第一个子表达式相匹配的文本（如果有的话） 第三个元素是与正则表达式的第二个子表达式相匹配的文本（如果有的话），以此类推… 非全局调用 exec() ，返回数组123456789101112131415var reg = /\\d(\\w)\\d/;var str = '1a2b3c4d5e';var ret = reg.exec(str);console.log(reg.lastIndex); // 0 非全局下，lastIndex 不生效，在此处无意义console.log(ret.index); // 0 匹配结果（1a2）的第一个字符在被检索的字符串(1a2b3c4d5e)中的位置console.log(ret.input); // 1a2b3c4d5econsole.log(ret.toString()); // 1a2,a 全局调用 exec() 时，可以通过循环可以把每次匹配到的结果都拿到12345678var reg = /\\d(\\w)(\\w)\\d/g;var str = '$1az2bb3cy4dd5ee';while(ret = reg.exec(str)) &#123; console.log(reg.lastIndex + '\\t' + ret.index + '\\t' + ret.toString()); // 5 1 1az2,a,z // 11 7 3cy4,c,y&#125; 第一次匹配到的字符串是 1az2 ，它在原字符串中的下一个字符的位置为 5 ，且它第一个字符 1 在原字符串的位置为 1，其中第一个子表达式 a，第二个子表达式 z 第二次匹配到的字符串是 3cy4 ，它在原字符串中的下一个字符的位置为 11 ，且它第一个字符 3 在原字符串的位置为 7，其中第一个子表达式 c，第二个子表达式 y 字符串的与正则相关的方法01-String.prototype.replace()replace() 方法的参数可以是一下几种方式： 1. replace( str, str )123'a1b'.replace('1', '2'); // \"a2b\"'a1b1c1'.replace('1', '2'); // \"a2b1c1\" 2. replace( str, reg )1'a1b1c1'.replace(/1/g, '2'); // \"a2b2c2\" 3. replace( str, function )示例：字符串中每个数字都加 1123456'a1b2c3d4e5'.replace(/\\d/g, function ( match, index, origin ) &#123; // 正则表达式没有分组内容 console.log(index); // 1 3 5 7 9 return parseInt(match) + 1;&#125;);// \"a2b3c4d5e6\" 示例：获取 url 中的查询参数123456789101112131415161718// 1. 准备工作：取得查询字符串// 假设当前 URL 为 'http://www.baidu.com?ie=UTF-8&amp;wd=regexp'// 可用如下方法获取查询字符串// var searchStr = location.search.slice(1); // 'ie=UTF-8&amp;wd=regexp'// 2. 利用正则获取查询参数var searchStr = 'ie=UTF-8&amp;wd=regexp';var paraObj = &#123;&#125;;searchStr.replace(/([^=&amp;]+)=([^=&amp;]*)/ig, function ( match, group1, group2, index, origin) &#123; console.log(match + '\\t' + group1 + '\\t' + group2 + '\\t' + index + '\\t' + origin); // ie=UTF-8 ie UTF-8 0 ie=UTF-8&amp;wd=regexp // wd=regexp wd regexp 9 ie=UTF-8&amp;wd=regexp paraObj[group1] = group2&#125;)console.log(paraObj); function 参数含义： 匹配字符串 正则表达式分组内容，没有分组则没有该参数 匹配项在字符串中的 index 原字符串 match group1 group2 index origin 第一次 ie=UTF-8 ie UTF-8 0 ie=UTF-8&amp;wd=regexp 第二次 wd=regexp wd regexp 9 ie=UTF-8&amp;wd=regexp String.prototype.search(reg) search() 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串 方法返回第一个匹配结果 index ，差找不到返回 -1 search() 不执行全局匹配，他将会略全局标志 g ，并且总是从字符串的开始进行检索 12'a1b2c3d4'.search('1');'a1b2c3d4'.search(/1/); 传入的参数不是正则的时候会尝试将其转换为正则 String.prototype.match(reg) match() 检索字符串，以找到一个或多个与正则表达式相匹配的文本 正则是否具有全局标志 g ，对结果影响很大 String.prototype.split(reg)123'a,b,c,d'.split(','); // [\"a\", \"b\", \"c\", \"d\"]'a1b2c3d'.split(/\\d/); // [\"a\", \"b\", \"c\", \"d\"]","tags":[{"name":"regexp","slug":"regexp","permalink":"https://wencaizhang.gitee.io/tags/regexp/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"js","slug":"oh-my-article/js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/"},{"name":"old","slug":"oh-my-article/js/old","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/old/"}]},{"title":"正则表达式","date":"2018-01-02T08:27:53.000Z","path":"wiki/oh-my-article/todoxxx/regexp/","text":"元字符元字符既可以是放在 [] 中的任意单个字符（如 [a] 表示匹配单个小写字符 a ） 也可以是字符序列（如 [a-d] 表示匹配 a 、 b 、 c 、 d 之间的任意一个字符，而 \\w 表示任意英文字母和数字及下划线） 下面是一些常见的元字符： 元字符 含义 . 匹配除 \\n 以外的任何字符（注意元字符是小数点）。 [abcde] 匹配 abcde 之中的任意一个字符 [a-h] 匹配 a 到 h 之间的任意一个字符 [^fgh] 不与 fgh 之中的任意一个字符匹配 \\w 匹配大小写英文字符及数字 0 到 9 之间的任意一个及下划线，相当于 [a-zA-Z0-9_] \\W 不匹配大小写英文字符及数字 0 到 9 之间的任意一个，相当于 [^a-zA-Z0-9_] \\s 匹配任何空白字符，相当于 [ \\f\\n\\r\\t\\v] \\S 匹配任何非空白字符，相当于 [^\\s] \\d 匹配任何 0 到 9 之间的单个数字，相当于 [0-9] \\D 不匹配任何 0 到 9 之间的单个数字，相当于 [^0-9] [\\u4e00-\\u9fa5] 匹配任意单个汉字（这里用的是 Unicode 编码表示汉字的 ) 正则表达式限定符上面的元字符都是针对单个字符匹配的，要想同时匹配多个字符的话，还需要借助限定符。 下面是一些常见的限定符 ( 下表中 n 和 m 都是表示整数，并且 0 &lt; n &lt; m) ： 限定符 含义 * 匹配 0 到多个元字符，相当于 {0,} ? 匹配 0 到 1 个元字符，相当于 {0,1} + 匹配至少 1 个元字符，相当于 {1,} {n} 匹配 n 个元字符 {n,} 匹配至少 n 个元字符 {n,m} 匹配 n 到 m 个元字符 \\b 匹配单词边界 ^ 字符串必须以指定的字符开始 $ 字符串必须以指定的字符结束 其他 由于在正则表达式中\\、?、*、^、$、+、(、)、|、{、[等字符已经具有一定特殊意义，如果需要用它们的原始意义，则应该对它进行转义，例如希望在字符串中至少有一个“ \\ ”，那么正则表达式应该这么写： \\+ 。 可以将多个元字符或者原义文本字符用括号括起来形成一个分组，比如 ^(13)[4-9]\\d{8}$ 表示任意以 13 开头的移动手机号码。 另外对于中文字符的匹配是采用其对应的 Unicode 编码来匹配的，对于单个 Unicode 字符，如 \\u4e00 表示汉字“一”， \\u9fa5 表示汉字“龥”，在 Unicode 编码中这分别是所能表示的汉字的第一个和最后一个的 Unicode 编码，在 Unicode 编码中能表示 20901 个汉字。 关于 \\b 的用法，它代表单词的开始或者结尾，以字符串 123a 345b 456 789d 作为示例字符串，如果正则表达式是 \\b\\d{3}\\b，则仅能匹配 456 。 可以使用 | 来表示或的关系，例如 [z|j|q] 表示匹配 z 、 j 、 q 之中的任意一个字母。 正则验证工具： https://regexper.com/ 正则对象属性 属性均为只读，无法设置其值 属性 含义 默认值 global 是否全文搜索 false ignoreCase 是否大小写敏感 false multiline 多行搜索 false lastIndex 是当前表达式匹配内容的最后一个字符的下一个位置 无 source 正则表达式的文本字符串 无 如下： 123456789101112var reg1 = /\\w/;var reg2 = /\\w/gim;console.log(reg1.global); // falseconsole.log(reg1.ignoreCase); // falseconsole.log(reg1.multiline); // falseconsole.log(reg1.source); // \"\\w\"console.log(reg2.global); // trueconsole.log(reg2.ignoreCase); // trueconsole.log(reg2.multiline); // trueconsole.log(reg2.source); // \"\\w\" 正则对象方法RegExp.prototype.test(str) 用于测试字符串参数中是否存在匹配正则表达式模式的字符串 如果存在则返回 true，否则返回 false 牛刀小试： 12345var reg = /\\w/;reg.test('a'); // truereg.test('ab'); // truereg.test('$'); // true 加上 g 标志后，结果有了一丝不同~~ 12345678var reg = /\\w/g;reg.test('ab'); // truereg.test('ab'); // truereg.test('ab'); // falsereg.test('ab'); // truereg.test('ab'); // truereg.test('ab'); // truereg.test('ab'); // false 这是因为在匹配的时候并不是每次都是从头开始的，而是每次匹配都会从上次匹配结果的下一个位置开始匹配，也就是 lastIndex 属性 第一次匹配到 a， 第二次从 b 开始，匹配到 b 第三次从 b 开始，没有匹配结果 因此出现上面的现象 12345var reg = /\\w/g;while(reg.test('ab')) &#123; console.log(reg.lastIndex);&#125;// 打印结果为 1，2 test() 本意测试字符串和正则能否匹配上，而不关心是在哪个位置匹配到，所以就没必要加上 g 标志。 RegExp.prototype.exec(str) 使用正则表达式对字符串进行搜索，并将更新全局 RegExp 对象的属性以反映匹配结果 如果没有匹配的文本则返回 null，否则返回一个结果数组，数组有两个属性： index 声明匹配文本地第一个字符的位置 input 存放被检索的字符串 string 第一个元素是与正则表达式相匹配的文本 第二个元素是与正则表达式的第一个子表达式相匹配的文本（如果有的话） 第三个元素是与正则表达式的第二个子表达式相匹配的文本（如果有的话），以此类推… 非全局调用 exec() ，返回数组123456789101112131415var reg = /\\d(\\w)\\d/;var str = '1a2b3c4d5e';var ret = reg.exec(str);console.log(reg.lastIndex); // 0 非全局下，lastIndex 不生效，在此处无意义console.log(ret.index); // 0 匹配结果（1a2）的第一个字符在被检索的字符串(1a2b3c4d5e)中的位置console.log(ret.input); // 1a2b3c4d5econsole.log(ret.toString()); // 1a2,a 全局调用 exec() 时，可以通过循环可以把每次匹配到的结果都拿到12345678var reg = /\\d(\\w)(\\w)\\d/g;var str = '$1az2bb3cy4dd5ee';while(ret = reg.exec(str)) &#123; console.log(reg.lastIndex + '\\t' + ret.index + '\\t' + ret.toString()); // 5 1 1az2,a,z // 11 7 3cy4,c,y&#125; 第一次匹配到的字符串是 1az2 ，它在原字符串中的下一个字符的位置为 5 ，且它第一个字符 1 在原字符串的位置为 1，其中第一个子表达式 a，第二个子表达式 z 第二次匹配到的字符串是 3cy4 ，它在原字符串中的下一个字符的位置为 11 ，且它第一个字符 3 在原字符串的位置为 7，其中第一个子表达式 c，第二个子表达式 y 字符串的与正则相关的方法01-String.prototype.replace()replace() 方法的参数可以是一下几种方式： 1. replace( str, str )123'a1b'.replace('1', '2'); // \"a2b\"'a1b1c1'.replace('1', '2'); // \"a2b1c1\" 2. replace( str, reg )1'a1b1c1'.replace(/1/g, '2'); // \"a2b2c2\" 3. replace( str, function )示例：字符串中每个数字都加 1123456'a1b2c3d4e5'.replace(/\\d/g, function ( match, index, origin ) &#123; // 正则表达式没有分组内容 console.log(index); // 1 3 5 7 9 return parseInt(match) + 1;&#125;);// \"a2b3c4d5e6\" 示例：获取 url 中的查询参数123456789101112131415161718// 1. 准备工作：取得查询字符串// 假设当前 URL 为 'http://www.baidu.com?ie=UTF-8&amp;wd=regexp'// 可用如下方法获取查询字符串// var searchStr = location.search.slice(1); // 'ie=UTF-8&amp;wd=regexp'// 2. 利用正则获取查询参数var searchStr = 'ie=UTF-8&amp;wd=regexp';var paraObj = &#123;&#125;;searchStr.replace(/([^=&amp;]+)=([^=&amp;]*)/ig, function ( match, group1, group2, index, origin) &#123; console.log(match + '\\t' + group1 + '\\t' + group2 + '\\t' + index + '\\t' + origin); // ie=UTF-8 ie UTF-8 0 ie=UTF-8&amp;wd=regexp // wd=regexp wd regexp 9 ie=UTF-8&amp;wd=regexp paraObj[group1] = group2&#125;)console.log(paraObj); function 参数含义： 匹配字符串 正则表达式分组内容，没有分组则没有该参数 匹配项在字符串中的 index 原字符串 match group1 group2 index origin 第一次 ie=UTF-8 ie UTF-8 0 ie=UTF-8&amp;wd=regexp 第二次 wd=regexp wd regexp 9 ie=UTF-8&amp;wd=regexp String.prototype.search(reg) search() 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串 方法返回第一个匹配结果 index ，差找不到返回 -1 search() 不执行全局匹配，他将会略全局标志 g ，并且总是从字符串的开始进行检索 12'a1b2c3d4'.search('1');'a1b2c3d4'.search(/1/); 传入的参数不是正则的时候会尝试将其转换为正则 String.prototype.match(reg) match() 检索字符串，以找到一个或多个与正则表达式相匹配的文本 正则是否具有全局标志 g ，对结果影响很大 String.prototype.split(reg)123'a,b,c,d'.split(','); // [\"a\", \"b\", \"c\", \"d\"]'a1b2c3d'.split(/\\d/); // [\"a\", \"b\", \"c\", \"d\"]","tags":[{"name":"regexp","slug":"regexp","permalink":"https://wencaizhang.gitee.io/tags/regexp/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"todoxxx","slug":"oh-my-article/todoxxx","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/todoxxx/"}]},{"title":"JavaScript 之深浅拷贝","date":"2018-01-02T02:42:53.000Z","path":"wiki/oh-my-article/js/object-clone-of-javascript/","text":"基本类型和引用类型先来看看 JavaScript 中两种数据类型有何异同。 基本类型和引用类型的保存方式不同。 基本数据类型是按值访问的。基本数据类型的值保存在栈内存中，可以直接对其操作。基本数据类型包含 5 种：Undefined、 Null、 Boolean、Number 和 String。 引用类型的值是按引用访问的。引用类型的值保存在堆内存中，另外在栈内存中会有一个引用指针指向堆内存中的对象，变量中保存的实际上是一个指针。在操作对象时，实际上是在操作对象的引用指针而不是实际的对象。 另外，基本类型和引用类型的复制方式也不同。 如果从一个变量向另一个变量复制基本类型的值，会在栈内存中创建一个新值，然后把值复制到新变量的位置上。例如：12var num1 = 5;var num2 = num1; 现在，将 num1 的值复制给 num2 ，两个变量中的值相同，但是 num2 的值只是 num1 的值的一个副本，因此两者是相互独立的，不会互相影响。 当一个变量向另一个变量复制引用类型的值，同样也会将储存在变量中的值复制一份到为新变量分配的空间中。但是这个值实际上是一个指针，指向储存在堆内存中的一个对象。复制结束后，两个变量存储的指针指向同一个对象，因此改变其中一个变量，就会影响到另一个变量。1234var obj1 = &#123; name: 'js' &#125;var obj2 = obj1;obj2.name = 'jquery';console.log( obj1.name ); // jquery 由此可见，基本数据类型的复制非常简单，直接使用赋值运算即可，无副作用。然而引用类型的复制则不能直接使用赋值运算，否则操作的仍是同一个对象，毫无意义。 故下面讨论的拷贝都是针对引用数据类型而言。 浅拷贝 demo我们说的复制，其实就是希望得到一个和原有对象有相同键值对集合（属性）的新对象，那么我们可以直接遍历对象，将键值对都储存在一个新的对象下，这样新对象和原对象就有一样的键值对集合（属性），也就达到我们的目标。 等一下，这里有个问题，如果某个属性值为引用类型，储存的值为对应的引用指针，则仍然会出现新变量和原有变量相互影响的问题。 以数组为例，若数组中元素都为基本数据类型： 第一步，遍历原数组，单独拷贝其中元素：12345678var arr = [ 1, 2, 3 ];var newArr = [];arr.forEach(function (item, index) &#123; newArr[index] = item;&#125;)console.log(arr); // [1, 2, 3]console.log(newArr); // [1, 2, 3] 第二步，修改新数组：1234newArr.push(4);console.log(arr); // [1, 2, 3]console.log(newArr); // [1, 2, 3, 4] 可以看到，修改 newArr ，原数组 arr 并未发生修改。 同样以数组为例，若数组中存在引用类型的元素： 第一步，遍历进行拷贝12345678var arr = [ 1, 2, [ 3, 4 ] ];var newArr = [];arr.forEach(function (item, index) &#123; newArr[index] = item;&#125;)console.log(arr); // [1, 2, [3, 4]]console.log(newArr); // [1, 2, [3, 4]] 第二步，修改新数组中嵌套的数组1234newArr[2].push(5);console.log(arr); // [1, 2, [3, 4, 5]]console.log(newArr); // [1, 2, [3, 4, 5]] 我们发现，无论是 arr 还是 newArr 都发生了变化。 当属性值为基本数据类型时，我们拷贝出来的新对象和原对象互不影响，当属性值为引用类型时，新对象和原对象在修改引用类型的属性值时相互影响。 所以说这种拷贝方式不够彻底，即浅拷贝。 总结浅拷贝的方法现在我们封装一个同时适用于 Array 和 Object 类型的浅拷贝的方法： 12345678910111213function shallowCopy (obj) &#123; if (typeof obj !== 'object') return obj; var newObj = obj instanceof Array ? [] : &#123;&#125;; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = obj[key]; &#125; &#125; return newObj;&#125; 注意几点： 只拷贝引用类型，基本数据类型直接返回即可 根据 obj 的类型来判断新建一个空数组或者空对象 遍历时，使用 hasOwnProperty() 过滤出对象实例的属性 总结深拷贝的方法上面演示了浅拷贝，浅拷贝存在的问题是引用类型的属性也是引用类型，但其实最终引用类型的键值也是由基本类型组成的。 如 var person = { name: &#39;jake&#39; } 中 person 是引用类型，但是 person 的属性名和属性值都是基本类型。 所以如果我们对其进行递归浅拷贝，总会拷贝到键值均为基本数据类型的那一步。 具体代码如下：12345678910111213function deepCopy (obj) &#123; if ( typeof obj !== 'object' ) return obj; var newObj = obj instanceof Array ? [] : &#123;&#125;; for ( var key in obj ) &#123; if ( obj.hasOwnProperty( key ) ) &#123; newObj[key] = typeof obj[key] === 'object' ? deepCopy( obj[key] ) : obj[key]; &#125; &#125; return newObj;&#125; 现在我们来测试一下：1234567var arr = [ 1, 2, [ 3, 4 ] ];var newArr = deepCopy(arr);newArr[2].push(5);console.log( arr[2] ); // [3, 4]console.log( newArr[2] ); // [3, 4, 5] 此时尽管 arr 中有引用类型的元素，通过深拷贝（递归浅拷贝）得到新对象 newArr 之后，修改其引用类型的属性可以发现，arr 和 newArr 不再互相影响，所以这种递归拷贝的方式叫做深拷贝。 封装深浅拷贝的方法上面分别总结了浅拷贝和深拷贝的方法，但是这两个方法的功能以及代码都有很大的相似度，我们可以考虑将它们封装成一个方法，通过多传入一个参数区分深拷贝和浅拷贝，如：extend( [deep], obj )。大致思路如下： 第一个参数 deep 为布尔类型，区分深浅拷贝，可忽略，忽略时视为浅拷贝（即默认值 false） 如果传入参数 deep 那么第二个参数是拷贝的目标对象，如果忽略 deep 参数，那么第一个参数就是拷贝的目标对象。 在为新建空对象的拷贝属性时，通过 deep 判断是否进行深拷贝。 代码如下：123456789101112131415161718192021function extend() &#123; var deep = false; var target = arguments[0]; var newObj, copy; if ( typeof target == 'boolean' ) &#123; deep = target; target = arguments[1]; &#125; newObj = target instanceof Array ? [] : &#123;&#125;; if ( typeof target !== 'object' ) return target; for ( var key in target ) &#123; if ( target.hasOwnProperty( key ) ) &#123; copy = target[ key ]; newObj[key] = deep &amp;&amp; typeof copy === 'object' ? extend(deep, copy) : copy; &#125; &#125; return newObj;&#125; 以数组为例测试一下：123456789var arr = [ 1, 2, [ 3, 4 ] ];var newArr = extend(false, arr);var newArr2 = extend(true, arr);newArr[2].push(5);console.log( arr[2] ); // [1, 2, [3, 4, 5]]console.log( newArr[2] ); // [1, 2, [3, 4, 5]]console.log( newArr2[2] ); // [1, 2, [3, 4]] 和预期一样，Good Job! 参考资料： JavaScript 高级程序设计 for…in · MDN Object.prototype.hasOwnProperty() · MDN How to Deep clone in javascript · stackoverflow How do I correctly clone a JavaScript object? · stackoverflow","tags":[{"name":"javascript","slug":"javascript","permalink":"https://wencaizhang.gitee.io/tags/javascript/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"js","slug":"oh-my-article/js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/"}]},{"title":"chrome 插件集","date":"2017-12-29T16:20:53.000Z","path":"wiki/oh-my-article/tool/awesome.-chrome-extensions/","text":"写在前面chrome 插件离线安装方法（chrome 插件通常以 crx 格式保存）： chrome 中打开 chrome://extensions/ 页面 把后缀为 crx 的插件安装文件拖拽到第一步打开的页面中 浏览器弹出确认安装的提示框，点击“添加扩展程序”即可 下面的插件都在百度云盘做了备份，网盘地址：https://pan.baidu.com/s/1gfCjRTD 插件介绍谷歌访问助手 - 访问谷歌 免费，简单 坏处：需要设置hao123为主页 cVim - 使Chrome浏览器支持Vim的快捷键 支持 vim 快捷键，解放鼠标 preview: JSONView - web开发 JSON 数据格式化和高亮插件 在做开发的时候，经常需要从服务器拿数据，一般返回数据都会用 json 来封装。由于一些原因，从服务器端取得的json数据，往往是经过unicode编码，没有格式化的数据，很难阅读。JSONView 正是应用与这个场景，它可以将json数据进行转码和格式化，以一种清晰的形式展示给大家 preview: Octotree - 你的 GitHub 文档库 装了这款插件之后，可以在 GitHub 项目页面的左侧看到相应项目的树状结构图，对于项目管理以及具体的文件跳转来说非常方便。 一键下载文件：GitHub 可以让你很方便的以 .zip 格式下载所有文件，但如果只需要下载一个文件，非常麻烦。使用 Octotree 之后，点击页面左侧项目的树状结构图中对应文件的图标即可下载。 preview: Page Ruler ：你的网页标尺 屏幕尺子插件，非常精确地测量出当前页面某个元素或者是整个页面的大小尺寸 preview: Awesome Autocomplete for GitHub ：属于 GitHub 的 「Alfred」 能够让你在不离开当前项目窗口的前提下，弹窗显示出你的搜索结果，非常方便 preview: Postman - 强大的 API &amp; HTTP 请求调试工具 官方网址：https://www.getpostman.com/ 不仅可以调试简单的 CSS、HTML、脚本等简单的网页基本信息，它还可以发送几乎所有类型的 HTTP 请求，Postman 在发送网络 HTTP 请求方面可以说是 Chrome 插件类产品中的代表产品之一 Infinity 新标签页 Chrome 新标签页应用，重绘了几百个图标，支持自定义搜索，集成天气，带有备忘与 Todo，还可以每日更换壁纸。 如果你已经厌倦了日复一日的默认新标签页，那就试一试 Infinity 吧！ 掘金 - 为设计师、程序员、产品经理每日发现优质内容 聚合了国内外优质的互联网站点内容，在节省你的筛选成本的同时，帮你发现好内容。 Proxy SwitchySharp - 轻松快捷地管理和切换多个代理设置 适用于需要经常切换网络代理的场景 windows 平台蛋疼的代理切换方式谁用谁知道~~~ WEB前端助手(FeHelper) 官方网站：WEB前端助手 前端开发，你值得拥有！~ 广告终结者 谁用谁知道，自从用了广告终结者，妈妈再也不用担心我看到广告了 猎豹翻译 英语学习药不能停！ 翻译类插件多如繁星，选择哪一款就看个人爱好了 preview: 为知笔记网页剪辑器 适合为知笔记用户 可以很方便的把网页上有价值的内容保存到自己的笔记中 新同文堂 - 网页简繁转换工具 浏览一些繁体中文网站时（如鳥哥的 Linux 私房菜）时还是很好用的 chrono 下载管理器 安装之后在浏览器的右上方可以看到其标记按钮，用户可以点击选择开始、暂停、取消等基础操作。还可以自行进行下载任务的添加，而且点击下载任务还会有对应的下载详情弹出，就像桌面上的下载软件一样。另外用户可以自行设置下载的时间顺序，甚至可以将 Chrome 默认只能同时下载 6 个文件的限制提升到 20 个 preview: Listen 1 - 同时搜索并播放来自「网易云音乐，虾米，QQ音乐」的歌曲 Listen 1，整合三大音乐平台的 Chrome 扩展 | App+1 preview:","tags":[{"name":"tool","slug":"tool","permalink":"https://wencaizhang.gitee.io/tags/tool/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"tool","slug":"oh-my-article/tool","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/tool/"}]},{"title":"Win下必备神器之Cmder","date":"2017-12-23T05:07:23.000Z","path":"wiki/oh-my-article/tool/awesome-windows-software-cmder/","text":"前言对于使用 windows 系统的，需要经常和命令行打交道的童鞋，强烈推荐一个工具：Cmder（Cmder官网: http://cmder.net/） 因为好用，所以必备 本该介绍 Cmder 是什么，如何安装，如何使用……，但是已经有前辈对此进行了详细介绍： Win下必备神器之Cmder 介绍好用工具：Cmder ( 具有Linux 温度的Windows 命令提示字元工具 ) 因此，本篇属于 Cmder 进阶篇，适合已经对 Cmder 有所了解的童鞋阅读，如果不知 Cmder 为何物，推荐先行阅读上面文章 Cmder 如何好用设置默认启动目录连接服务器因为 Cmder 支持 ssh 命令，因此可以直接连接服务器，命令为：ssh 用户名@ip，例如：1ssh root@10.2.5.187 定义 alias 每次连接服务器都需要输入一长串命令，简直不能忍。好在 Cmder 提供了定义 alias 的功能。配置文件是 cmder\\config\\user-aliases.cmd，打开之后会发现，Cmder 已经默认定义了一些 alias。 123456789e.=explorer .gl=git log --oneline --all --graph --decorate $*ls=ls --show-control-chars -F --color $*pwd=cdclear=clshistory=cat \"%CMDER_ROOT%\\config\\.history\"unalias=alias /d $1vi=vim $*cmderr=cd /d \"%CMDER_ROOT%\" 先解释默认定义的这些 alias 的作用 e. : 用资源管理器打开 Cmder 当前所在路径 gl : 使用 git 进行代码管理的童鞋应该不陌生，git log 加上一些参数 ls : 列出当前目录下的文件和目录 pwd : 打印当前目录的完整路径名 clear : 清除屏幕 history : 显示历史命令 unalias : 这个，谁知道能告诉我一声么。。。 vi : 打开 vim 编辑器 cmderr : 切换到 Cmder.exe 所在的目录下 一键切换到指定目录 1tofe=cd /d D:/www/front-end/ 一键连接服务器 12totest=ssh root@10.2.5.187todev=ssh root@10.2.5.188 更多 alias 的可自由发挥~ 各种主题more最后 过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写作，不外出，不折腾……但是，人生最后悔的事情就是：我本可以。——陈素封。","tags":[{"name":"tool","slug":"tool","permalink":"https://wencaizhang.gitee.io/tags/tool/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"tool","slug":"oh-my-article/tool","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/tool/"}]},{"title":"切换浏览器 tab 标签时动态设置网页 title","date":"2017-12-22T13:50:23.000Z","path":"wiki/oh-my-article/js/toggle-title-on-focus-and-blur/","text":"效果在饿了么官网看到一个网页效果，在饿了么网页和其他标签页之间相互切换时，饿了么网页的 title，发生了变化。 饿了么官网: https://www.ele.me/home/ 效果如下： 代码实现预备知识 visibilitychange 事件，会在浏览器标签页被隐藏或显示的时候会触发 document.hidden ，只读属性，返回一个布尔值标识当前页面是否隐藏 document.visibilityState，只读属性，返回 document 的可见性，有 4 个值： visible : 此时页面内容至少是部分可见。 即此页面在前景标签页中，并且窗口没有最小化 hidden : 此时页面对用户不可见。即文档处于背景标签页或者窗口处于最小化状态，或者操作系统正处于锁屏状态 prerender : 页面此时正在渲染中， 因此是不可见的. 文档只能从此状态开始，永远不能从其他值变为此状态 unloaded : 页面从内存中卸载清除 具体实现 使用 document.hidden 属性 12345678910var titleFocus = '饿了么';var titleBlur = '记得回来哦';function toggleTitleHandler(bool) &#123; document.title = bool ? titleBlur : titleFocus;&#125;document.addEventListener(\"visibilitychange\", function () &#123; toggleTitleHandler(document.hidden);&#125;, false); 使用 document.visibilityState 属性 12345678910var titleFocus = '饿了么';var titleBlur = '记得回来哦';function toggleTitleHandler(visibilityState) &#123; document.title = visibilityState === 'hidden' ? titleBlur : titleFocus;&#125;document.addEventListener(\"visibilitychange\", function () &#123; toggleTitleHandler(document.visibilityState);&#125;, false); 其他 此 API 存在兼容性问题，支持 IE10+ 推荐阅读： Page Visibility(页面可见性) API介绍、微拓展 - 张鑫旭（PS：此处献上我的膝盖）","tags":[{"name":"javascript","slug":"javascript","permalink":"https://wencaizhang.gitee.io/tags/javascript/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"js","slug":"oh-my-article/js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/"}]},{"title":"Gulp 调试小技巧","date":"2017-11-28T13:30:53.000Z","path":"wiki/oh-my-article/todoxxx/gulp-debug/","text":"编写 gulp 任务时，经常会遇到错误的情况，导致任务执行过程被中断，可以通过事件监听的方式打印错误，并让任务继续往下执行。 基础版主要的思路是通过事件监听把错误打印出来，然后定位错误。 这是部分代码：123.pipe(uglify().on('error', function (e) &#123; console.log(e)&#125;)) 升级版其实就是稍微简单封装一下。 12345678910111213function createErrorHandler(name) &#123; return function (err) &#123; console.error('Error from ' + name + ' in compress task', err.toString()); &#125;;&#125;gulp.task('minify_js', function () &#123; var uglify = require('gulp-uglify'); return gulp.src('./build/**/*.js') .pipe(uglify().on('error', createErrorHandler('uglify'))) .pipe(gulp.dest('build')) .pipe($.size(&#123; title: 'minify_js' &#125;));&#125;)","tags":[{"name":"gulp","slug":"gulp","permalink":"https://wencaizhang.gitee.io/tags/gulp/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"todoxxx","slug":"oh-my-article/todoxxx","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/todoxxx/"}]},{"title":"Linux Tips","date":"2017-11-26T13:20:53.000Z","path":"wiki/oh-my-article/todoxxx/Linux-tips/","text":"积累记录一些常用 Linux 命令。 修改普通用户对目录的读写权限普通用户是没有文件的读写权限的，需要每次都临时获取 root 权限，但这样比较麻烦。方便的做法是，修改/var/www目录的读写权限（777是linux中的最高权限，表示可读，可写，可执行）1sudo chmod 777 /var/www 设置别名 alias编辑配置文件 vim /etc/profile，在文件中添加配置代码，例如：12alias tofe=\"cd /var/www/rmp/spms/front-end/\"alias gs=\"git status\" 设置环境变量","tags":[{"name":"linux","slug":"linux","permalink":"https://wencaizhang.gitee.io/tags/linux/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"todoxxx","slug":"oh-my-article/todoxxx","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/todoxxx/"}]},{"title":"GET 和 POST 的区别","date":"2017-11-25T15:31:23.000Z","path":"wiki/oh-my-article/js/the-difference-of-get-and-post-method/","text":"从表象上看： GET 参数通过 URL 传递，POST 放在 Request body 中。 GET 产生的 URL 地址可以被记录到浏览器历史中，而 POST 不可以。 GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。 GET 请求在URL中传送的参数是有长度限制的，而 POST 没有。 底层来看：无区别 解释如下： 给 GET 加上 request body，给 POST 带上 url 参数，技术上是完全行的通的 为了给不同的区别不同类型的请求，才定义了 GET、POST、PUT、DELETE，依次对应 查、改、增、删 业界不成文的规定是，（大多数）浏览器通常都会限制 url 长度在 2K 个字节，而（大多数）服务器最多处理 64K 大小的 url。超过的部分，恕不处理。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://wencaizhang.gitee.io/tags/javascript/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"js","slug":"oh-my-article/js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/"}]},{"title":"trim 方法","date":"2017-11-25T13:31:23.000Z","path":"wiki/oh-my-article/js/trim 方法/","text":"前言 trim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR）。 删除字符串两端的空白字符可以说是非常常见的需求 我通常用的是 jQuery 提供的 $.trim() 方法，但其实原生 JavaScript 已经提供了 trim() 方法，IE9 以上浏览器已经支持此方法，而且 MDN 文档 也已经提供了兼容旧环境的方法。 so，以后并不一定非要依赖第三方库，完全可以使用原生 tirm() 方法，或者自定义此方法的兼容写法。 通过正则简单实现：123456789101112131415if(!String.prototype.trim) &#123; String.prototype.trim = function () &#123; return this.replace(/^\\s+|\\s+$/g,''); &#125;;&#125;if(!String.prototype.trimLeft) &#123; String.prototype.trimLeft = function () &#123; return this.replace(/^\\s+/,''); &#125;;&#125;if(!String.prototype.trimRight) &#123; String.prototype.trimRight = function () &#123; return this.replace(/\\s+$/,''); &#125;;&#125; 用到的正则： \\s 匹配任何空白字符 + 匹配至少 1 个元字符 ^ 字符串必须以指定的字符开始 $ 字符串必须以指定的字符结束 | 或者 g 全局匹配 more： 更多的实现方式参考：JavaScript trim函数大赏 - 司徒正美 MDN 文档：String.prototype.trim() - MDN","tags":[{"name":"javascript","slug":"javascript","permalink":"https://wencaizhang.gitee.io/tags/javascript/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"js","slug":"oh-my-article/js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/"}]},{"title":"trim 方法","date":"2017-11-25T13:31:23.000Z","path":"wiki/oh-my-article/js/old/function-trim/","text":"前言 trim() 方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR）。 删除字符串两端的空白字符可以说是非常常见的需求 我通常用的是 jQuery 提供的 $.trim() 方法，但其实原生 JavaScript 已经提供了 trim() 方法，IE9 以上浏览器已经支持此方法，而且 MDN 文档 也已经提供了兼容旧环境的方法。 so，以后并不一定非要依赖第三方库，完全可以使用原生 tirm() 方法，或者自定义此方法的兼容写法。 通过正则简单实现：123456789101112131415if(!String.prototype.trim) &#123; String.prototype.trim = function () &#123; return this.replace(/^\\s+|\\s+$/g,''); &#125;;&#125;if(!String.prototype.trimLeft) &#123; String.prototype.trimLeft = function () &#123; return this.replace(/^\\s+/,''); &#125;;&#125;if(!String.prototype.trimRight) &#123; String.prototype.trimRight = function () &#123; return this.replace(/\\s+$/,''); &#125;;&#125; 用到的正则： \\s 匹配任何空白字符 + 匹配至少 1 个元字符 ^ 字符串必须以指定的字符开始 $ 字符串必须以指定的字符结束 | 或者 g 全局匹配 more： 更多的实现方式参考：JavaScript trim函数大赏 - 司徒正美 MDN 文档：String.prototype.trim() - MDN","tags":[{"name":"javascript","slug":"javascript","permalink":"https://wencaizhang.gitee.io/tags/javascript/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"js","slug":"oh-my-article/js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/"},{"name":"old","slug":"oh-my-article/js/old","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/old/"}]},{"title":"vuex 状态管理","date":"2017-11-24T12:20:53.000Z","path":"wiki/oh-my-article/vue/04-vuex状态管理/","text":"从使用的角度来看 存取状态 用户操作 异步请求 [toc] What is thisVuex 是使用 vue 开发大型项目用来管理应用状态的一个很好的选择。 这里尽量不出现各种概念，只有一些很基本的使用方法，目的是可以让您在最短的时间内将 Vuex 使用起来。然后在使用的过程中，再去慢慢理解体会其中的设计理念。 使用引入1. 安装1npm install vuex -D 2. 创建实例在 src 目录下创建 store 目录，然后新建 index.js，内容如下： 1234567891011121314import Vue from 'vue'import vuex from 'vuex'Vue.use(vuex)const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;) 3. 将状态从根组件“注入”到每一个子组件中把上面创建的 store 对象提供给 vue 实例的 “store” 选项，这可以把 store 的实例注入所有的子组件，进而在所有的子组件中都可以通过 this.$store 访问到 store 对象。 12345678import Vue from 'vue'import store from './store'new Vue(&#123; el: '#app', store, render: h =&gt; h(App)&#125;); 实战在子组件中访问 store 对象123456// ... some codecomputed: &#123; count () &#123; return this.$store.state.count &#125;&#125; getterVuex 的状态存储是响应式的，读取状态最简单的方法就是在计算属性中返回某个状态。 如果不是简单返回某个状态，而是需要对某个状态做一些处理（派生出一些状态），恰好也有别的组件需要用到的时候，就可以用 getter 属性，相当于是 Vuex 的计算属性。 例如：state 中有数组 todos，现在要获取数组中 done 属性值为 true 的元素： 1234567891011121314const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) 在子组件调用12345computed: &#123; doneTodosCount () &#123; return this.$store.getters.doneTodosCount &#125;&#125; 一些链接 Vuex 文档","tags":[{"name":"vue","slug":"vue","permalink":"https://wencaizhang.gitee.io/tags/vue/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"vue","slug":"oh-my-article/vue","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/vue/"}]},{"title":"axios 封装","date":"2017-11-24T12:20:53.000Z","path":"wiki/oh-my-article/vue/07-axios 封装/","text":"拦截器如果你想要在每次发送 ajax 请求或者收到 ajax 响应的时候进行一些处理，那么你可以使用 axios 请求拦截器和响应拦截器 请求拦截器1234567891011// 添加请求拦截器axios.interceptors.request.use( config =&gt; &#123; // 在发送请求之前做些什么 return config; &#125;, error =&gt; &#123; // 对请求错误做些什么 return Promise.reject(error); &#125;); 响应拦截器1234567891011// 添加响应拦截器axios.interceptors.response.use( response =&gt; &#123; // 对响应数据做点什么 return response; &#125;, error =&gt; &#123; // 对响应错误做点什么 return Promise.reject(error); &#125;);","tags":[{"name":"vue","slug":"vue","permalink":"https://wencaizhang.gitee.io/tags/vue/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"vue","slug":"oh-my-article/vue","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/vue/"}]},{"title":"VScode 编辑器自定义代码段","date":"2017-11-24T12:20:53.000Z","path":"wiki/oh-my-article/tool/vscode自定义代码段/","text":"创建方式：vscode 编辑器中依次选择 文件 -&gt; 首选项 -&gt; 用户代码片段，此时会打开一个选择框，用于选择代码片段文件或者创建代码片段，在下拉框中找到对应的 vue 选项，点击选中 vue 选项后会自动打开 vue.json 文件，用下面代码段将文件中内容全部替换掉。 然后在后缀为 vue 的空白文件中，打印 vue 并按下 tab 键，即可自动生成刚刚定义好的代码段。 // vue.json1234567891011121314151617181920212223242526272829&#123; \"Print to console\": &#123; \"prefix\": \"vue\", \"body\": [ \"&lt;template&gt;\", \" &lt;section&gt;\", \" $1\", \" &lt;/section&gt;\", \"&lt;/template&gt;\", \"\", \"&lt;script&gt;\", \"export default &#123;\", \" name: '',\", \" data () &#123;\", \" return &#123;\", \" $2\", \" &#125;\", \" &#125;,\", \" methods: &#123;\", \" &#125;,\", \"&#125;\", \"&lt;/script&gt;\", \"\", \"&lt;style scoped&gt;\", \"\", \"&lt;/style&gt;\", ], \"description\": \"生成vue文件模板\"&#125; 生成对应的代码 12345678910111213141516171819202122&lt;template&gt; &lt;section&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &apos;&apos;, data () &#123; return &#123; &#125; &#125;, methods: &#123; &#125;,&#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;","tags":[{"name":"tool","slug":"tool","permalink":"https://wencaizhang.gitee.io/tags/tool/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"tool","slug":"oh-my-article/tool","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/tool/"}]},{"title":"用户登录状态管理","date":"2017-11-24T12:20:53.000Z","path":"wiki/oh-my-article/vue/01-用户登录状态管理/","text":"逻辑 当用户访问站点时，在路由拦截器里判断 cookie 里面是否有 username 或者 token 或者 sessionId 之类的标识，如果有：表示“已登陆”，否则跳转到登陆页面； 如果已登陆，跳转到相应路由，对应页面调用 api 获取数据，否则提示”未登陆”，跳转到登陆页； 正常登陆，保存用户信息到 cookie 储存用户信息方案同时使用 vuex 和 localStorage 储存用户信息 最简单的做法就是本地没数据就登录，有数据就刷新，后台判断数据过期了就清除数据再登录。 本地储存用户信息是为了避免页面刷新导致数据丢失的问题， 为统一管理 app 状态，使用 vuex 储存数据，另外，与在内存中的 state 相比，怕是其他方式都是慢的。 使用 vuex 管理状态，但是页面刷新时，state 中的信息就会清空，因此需要同时在本地存储用户信息 关于本地储存方案用户登录成功以后应该在本地保存一份用户数据，注意保存本地的方法有很多种，比如 cookie 、localStorage、indexedDB 等。 这里使用的是 localStorage，但是代码中并没有直接调用 window.localStorage，而是封装一个用户数据的读取函数，解除代码耦合，将来要改成其他存储方式比较简单： 12function getUserinfo()&#123;&#125;function setUserinfo()&#123;&#125; 可以存到 localStorage 里面，只是不能直接用 window.localStorage 相关函数的原因如下： 假设一个情景，在前期我们要求把用户信息存储在 localStorage 中，但是后期，我们又不想存在这里，我们希望存在 cookie 甚至其它地方。 那么如果使用直接调用 window.localStorage 的写法，需要替换项目中的所有 localStorage 调用，所以这里提取出一层，即 model 层，或者说是存储层。 这样我们就不需要修改所有项目中的 localStorage 调用，只需要修改 model 层中的 localStorage 调用，将其改为 cookie 或者其它形式。 这样保持我们调用方式不变：getUserinfo，同时还减小工作量，降低误差。 在团队的分工合作中，负责这一层的团队成员直接从 localStorage 切换成 cookie 也不会对上层的团队成员造成影响。也就是我随意切换存储方式，不和任何人打招呼我自己也能完成，还不影响他们。 而且独立出来以后我可以针对这一部分直接做单元测试，对项目的维护也有很大帮助。 每次页面跳转之前检测权限利用 vue-router 提供的守卫 beforeEach，在每次页面跳转之前检测当前用户权限，并进行处理。 src/main.js 中 123456789101112router.beforeEach((to, from, next) =&gt; &#123; const userInfo = util.getUserinfo(); let isLogin = store.state.user.login; let notCheckLogin = to.matched.some( record =&gt; record.meta.notCheckLogin ) // 未登录，且需要检测登录状态的路由 if (!userInfo &amp;&amp; !isLogin &amp;&amp; !notCheckLogin)&#123; next(&#123; path: '/login' &#125;); &#125; else &#123; next(); &#125;&#125;); 遇到这样一个问题，如图所示，代码无限循环执行： 主要原因是判断条件不严谨，判断条件永远成立，导致死循环，这点需要注意。 https://segmentfault.com/q/1010000014983955 https://segmentfault.com/q/1010000012121359 https://segmentfault.com/q/1010000012065855 其他理论上应该有一个接口用来更新用户状态，比如判断用户是否需要重新登录之类的，比如api/refresh， 所以逻辑应该是： 用户进入app，判断本地是否有用户信息。 如果有，调用 api/refresh，判断是否需要重新登录。 不需要（连续登录），将信息保存在 vuex 中，并进入首页，往后数据读取全部走 vuex。 需要（长时间未登录），删除本地用户信息并跳转到登录流程。 如果没有， 跳转到登录流程（以下是登录流程）。 调用 api/login 登录。 将保存到本地，并保存到 vuex 中，往后数据读取全部走 vuex。","tags":[{"name":"vue","slug":"vue","permalink":"https://wencaizhang.gitee.io/tags/vue/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"vue","slug":"oh-my-article/vue","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/vue/"}]},{"title":"vuex 状态持久化之vuex-persistedstate","date":"2017-11-24T12:20:53.000Z","path":"wiki/oh-my-article/vue/09-vuex 状态持久化/","text":"安装1$ npm install vuex-persistedstate 使用123456import createPersistedState from \"vuex-persistedstate\";const store = new Vuex.Store(&#123; // ... plugins: [createPersistedState()]&#125;); APIcreatePersistedState([options])：通过配置选项创建实例。 你可以通过下面给出的选项配置你需要的插件实例： key &lt;String&gt;: The key to store the persisted state under. (default: vuex) paths &lt;Array&gt;: An array of any paths to partially persist the state. If no paths are given, the complete state is persisted. (default: []) reducer &lt;Function&gt;: A function that will be called to reduce the state to persist based on the given paths. Defaults to include the values. subscriber &lt;Function&gt;: A function called to setup mutation subscription. Defaults to store =&gt; handler =&gt; store.subscribe(handler) storage &lt;Object&gt;: Instead for (or in combination with) getState and setState. Defaults to localStorage. getState &lt;Function&gt;: A function that will be called to rehydrate a previously persisted state. Defaults to using storage. setState &lt;Function&gt;: A function that will be called to persist the given state. Defaults to using storage. filter &lt;Function&gt;: A function that will be called to filter any mutations which will trigger setState on storage eventually. Defaults to () =&gt; true arrayMerger &lt;Function&gt;: A function for merging arrays when rehydrating state. Defaults to function (store, saved) { return saved } (saved state replaces supplied state). 自定义如果你不想在 localStorage 中储存 Vuex 的状态，你可以轻松地使用 cookies 实现这个功能（或任何其他你可以想到的）： 123456789101112131415161718import &#123; Store &#125; from \"vuex\";import createPersistedState from \"vuex-persistedstate\";import * as Cookies from \"js-cookie\";const store = new Store(&#123; // ... plugins: [ createPersistedState(&#123; storage: &#123; getItem: key =&gt; Cookies.get(key), // Please see https://github.com/js-cookie/js-cookie#json, on how to handle JSON. setItem: (key, value) =&gt; Cookies.set(key, value, &#123; expires: 3, secure: true &#125;), removeItem: key =&gt; Cookies.remove(key) &#125; &#125;) ]&#125;); 实际上，storage 可以传递任何遵循存储协议（getItem，setItem，removeItem等）的对象: 1createPersistedState(&#123; storage: window.sessionStorage &#125;); 你可以在这里传入一个 dom-storage 的实例，当这个插件与服务器端渲染结合使用时非常有用。","tags":[{"name":"vue","slug":"vue","permalink":"https://wencaizhang.gitee.io/tags/vue/"},{"name":"storage","slug":"storage","permalink":"https://wencaizhang.gitee.io/tags/storage/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"vue","slug":"oh-my-article/vue","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/vue/"}]},{"title":"手机端键盘弹起优化","date":"2017-11-24T12:20:53.000Z","path":"wiki/oh-my-article/vue/11-键盘弹起优化/","text":"问题背景页面布局大致如下 1234567891011&lt;template&gt; &lt;header&gt;Logo&lt;/header&gt; &lt;form&gt; &lt;input type=\"text\" &gt; &lt;input type=\"password\" &gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;footer&gt; 版权信息 &lt;/footer&gt;&lt;/template&gt; header 和 form 都是 static 定位，footer 使用 absolute 或者 fixed 定位在页面底部。 问题描述当 input 获取焦点键盘弹起时，页面仅剩键盘上方区域，因此 footer 随之往上移动保持在页面的底部。 最终导致的结果就是 footer 和 form 重合叠加在一起。 解决思路首先获取页面一开始加载完成时候的高度，然后监听屏幕高度，如果监听到的屏幕高度小于原始页面高度，说明键盘弹起，此时隐藏 footer，如果屏幕高度等于原始页面高度，说明键盘未弹起，此时显示 footer。 代码实现这里使用 vue 实现，仅展示关键代码 template 部分 1234567891011&lt;template&gt; &lt;header&gt;Logo&lt;/header&gt; &lt;form&gt; &lt;input type=\"text\" &gt; &lt;input type=\"password\" &gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;footer v-if=\"isOriginHei\"&gt; 版权信息 &lt;/footer&gt;&lt;/template&gt; js 部分： 1234567891011121314151617181920212223data() &#123; return &#123; isOriginHei: true, screenHeight: document.documentElement.clientHeight, //此处也可能是其他获取方法 originHeight: document.documentElement.clientHeight, &#125;;&#125;,watch: &#123; screenHeight (val) &#123; if(this.originHeight &gt; val + 100) &#123; //加100为了兼容华为的返回键 this.isOriginHei = false; &#125;else&#123; this.isOriginHei = true; &#125; &#125;&#125;,mounted () &#123; window.onresize = () =&gt; &#123; return (() =&gt; &#123; this.screenHeight = document.documentElement.clientHeight; &#125;)() &#125;&#125;","tags":[{"name":"vue","slug":"vue","permalink":"https://wencaizhang.gitee.io/tags/vue/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"vue","slug":"oh-my-article/vue","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/vue/"}]},{"title":"header和footer组件化","date":"2017-11-24T12:20:53.000Z","path":"wiki/oh-my-article/vue/header-and-footer组件化/","text":"我们在建设网站时总会遇到这样的问题：在大部分的页面我们需要显示 header 和 footer，分别用于展示网站 logo、顶部导航和底部版权信息等内容。 在 vue 项目中我们可以将 header 和 footer 单独抽取为两个组件，然后在每个路由对应的组件中分别引入 header 和 footer 。 这种方法相对来说已经很简洁了，但是仍然存在一些问题，即重复代码太多（需要重复的引入 header 和 footer，然后在 template 中进行渲染）。 Don’t repeat youself. 这里有另外一种更加简单的方式，其关键思路是利用 vue-router 的命名视图来解决这个问题。（vue-router 命名视图：文档地址） 下面是一个简单示例： 在 App.vue 中创建三个视图（router-view)，它们有不同的 name 属性，如果没有则默认为 default。 1234567&lt;template&gt; &lt;div id=\"app\"&gt; &lt;router-view name='header'&gt;&lt;/router-view&gt; &lt;router-view &gt;&lt;/router-view&gt; &lt;router-view name='footer'&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 在路由文件 router.js 中进行路由设置，在 components 属性中分别为上面三个视图传入不同的组件。 components 是一个 Object，它的每个键分别对应着 App.vue 中的三个视图的 name 值，它的属性值是一个组件，会被渲染到相应的视图中。 例如在路由 home 下，三个路由视图分别由 Header ，Home ， Footer 三个组件渲染。 如果某个页面不需要渲染 header 和 footer ，则无需理会 header 视图和 footer 视图，也就是说不需要给 components 的 header 属性和 footer 属性设置属性值。甚至可以用更简洁的写法，使用 component 替换掉 components （注意 s ）。 例如路由 login 中的 component: Login 。 12345678910111213141516171819202122import Header from \"../components/Header\"import Footer from \"../components/Footer\"import Home from \"../pages/Home\"import Login from \"../pages/Login\"export default [ &#123; path: '/home', name: 'home', components: &#123; default: Home, header: Header, footer: Footer &#125; &#125;, &#123; path: '/login', name: 'login', component: Login, &#125;,]","tags":[{"name":"vue","slug":"vue","permalink":"https://wencaizhang.gitee.io/tags/vue/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"vue","slug":"oh-my-article/vue","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/vue/"}]},{"title":"本地存储数据方案分析","date":"2017-11-24T12:20:53.000Z","path":"wiki/oh-my-article/vue/08-本地存储数据方案分析/","text":"浏览器本地存储有时候为了存储一些数据，比如用户信息，需要用到浏览器的存储能力。 浏览器本地存储数据有三种方案：cookie、localStorage 和 sessionStorage。 下面分别是这三者的特点。 cookie 几乎支持所有浏览器 存储数据大小不能超过 4 k cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 cookie 会被附加到每个 HTTP 请求头中，如果使用cookie保存过多数据会带来性能问题 需自行封装操作 cookie 的方法（ vux 提供了操作 cookie 的方法） web storage 支持 IE8+，可以放心使用 储存数据大小在 5M 左右，如果储存超过最大容量，会弹出请求更多储存空间的对话框 localStorage 没有时间限制的数据存储，本地离线储存，关闭浏览器之后数据不丢失，sessionStorage 针对一个session进行数据存储。当用户关闭浏览器后数据会被删除 仅在客户端（即浏览器）中保存，不参与和服务器的通信 拥有 setItem, getItem, removeItem, clear 等操作方法 强调一点，就是 localStorage 和 sessionStorage 的区别： sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此 sessionStorage 不是一种持久化的本地存储，仅仅是会话级别的存储。 而 localStorage 用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 项目实际需求分析token 和 userId登录成功，返回两个字段 token 和 userId。 在接下来的每次请求中，都需要将 token 添加到请求头中，否则无法成功请求数据。 userId 在“我”页面获取用户信息时作为参数向后台传递。 为保证页面刷新之后仍然保持登录状态并且能够请求用户信息，这两个字段需进行本地储存（cookie） data用户以扫描二维码形式获取页面链接，链接中有 data 字段。 data 字段用来获取考试信息，因此，data 字段也需要进行本地储存。 其他todo: 考试题目的 ids 和 每个题目信息 以及用户的答案数据 是否需要本地储存呢？","tags":[{"name":"vue","slug":"vue","permalink":"https://wencaizhang.gitee.io/tags/vue/"},{"name":"storage","slug":"storage","permalink":"https://wencaizhang.gitee.io/tags/storage/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"vue","slug":"oh-my-article/vue","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/vue/"}]},{"title":"动态设置网页 title","date":"2017-11-24T12:20:53.000Z","path":"wiki/oh-my-article/vue/02-设置网页title/","text":"单页面应用的一个问题就是网页 title 无法随着路由而变化，这里我们使用 vue-wechat-title 解决这个问题。 安装：1npm install vue-wechat-title --save 引用12345import vueRouter from \"vue-router\"import VueWechatTitle from 'vue-wechat-title'Vue.use(VueWechatTitle)Vue.use(vueRouter) 调用1&lt;router-view v-wechat-title='$route.meta.title'&gt;&lt;/router-view&gt; 给每个路由设置 title12345678910111213141516&#123; path: '/login', name: 'login', component: Login, meta: &#123; title: '已有账号？请登录' &#125;&#125;,&#123; path: '/forget', name: 'forget', component: Forget, meta: &#123; title: '找回密码' &#125;&#125;","tags":[{"name":"vue","slug":"vue","permalink":"https://wencaizhang.gitee.io/tags/vue/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"vue","slug":"oh-my-article/vue","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/vue/"}]},{"title":"样式私有化","date":"2017-11-24T12:20:53.000Z","path":"wiki/oh-my-article/vue/03-样式私有化/","text":"使用 CSS modulesCSS modules因为 css 规则是全局有效的，因此特别容易发生样式冲突（污染）的问题， 使用 css modules 之前，通常为了避免冲突，会把 class 命名写长，配合父元素选择器限制范围。 使用 css modules 之后，构建工具可以帮我们把类名编译成含有哈希值的类名。 1&lt;h3 class=\"src-pages-WaitForExam---red---1wBGt_0\"&gt;注意事项&lt;/h3&gt; 因此我们可以不用关心样式冲突问题，只需要使用约定的格式书写即可。 使用 css modules webpack 配置 可以使用vue-loader的cssModules选项为css-loader进行自定义的配置 1234567891011121314module: &#123; rules: [ &#123; test: '\\.vue$', loader: 'vue-loader', options: &#123; cssModules: &#123; localIdentName: '[path][name]---[local]---[hash:base64:5]', camelCase: true &#125; &#125; &#125; ]&#125; 具体使用在 style 标签中添加 module 属性，表示使用 css modules12345&lt;style module&gt;.red &#123; color: red;&#125;&lt;/style&gt; 在 template 中动态绑定类名（:class），并使用 $style 通过 . 调用12345678&lt;template&gt; &lt;p :class=\"$style.red\"&gt;一个段落&lt;/p&gt;&lt;/template&gt;&lt;style module&gt;.red &#123; color: red;&#125;&lt;/style&gt; 如果类名包含中划线，则通过中括号调用12345678&lt;template&gt; &lt;p :class=\"$style['red-p']\"&gt;一个段落&lt;/p&gt;&lt;/template&gt;&lt;style module&gt;.red-p &#123; color: red;&#125;&lt;/style&gt; 同时拥有多个类名，可以使用数组1234567891011&lt;template&gt; &lt;p :class=\"[$style.red, $style.text]\"&gt;一个段落&lt;/p&gt;&lt;/template&gt;&lt;style module&gt;.red &#123; color: red;&#125;.text &#123; text-align: center;&#125;&lt;/style&gt; 还可以使用对象，动态切换类名1234567891011121314151617&lt;template&gt; &lt;p :class=\"&#123; [$style.red] : isRed &#125;\"&gt;一个段落&lt;/p&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; isRed: false &#125;; &#125;,&#125;&lt;/script&gt;&lt;style module&gt;.red &#123; color: red;&#125;&lt;/style&gt;","tags":[{"name":"vue","slug":"vue","permalink":"https://wencaizhang.gitee.io/tags/vue/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"vue","slug":"oh-my-article/vue","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/vue/"}]},{"title":"好用工具集合","date":"2017-11-24T12:20:53.000Z","path":"wiki/oh-my-article/tool/awesome-tools/","text":"工欲善其事必先利其器轻功不代表武功，但是速度，决定了你和我的距离 qimage-win - windows 版本 markdown 一键贴图工具 地址：https://github.com/jiwenxing/qiniu-image-tool-win/releases 简介：windows版本markdown一键贴图工具，支持本地文件、截图、网络图片一键上传七牛云并返回图片引用，让markdown中贴图变成一种享受。 preview： cmder - 程序员的命令行神器（windows 平台） 地址：http://cmder.net/ 简介：windows 平台最好用的命令行 可代替 cmd 和 powershell 自带 Git 支持 ssh 协议，可作为虚拟终端登录服务器 支持部分 Linux 命令 preview： clover - 为您的 Windows Explorer 插上翅膀！ 地址：http://cn.ejie.me/ 简介：Clover 是 Windows Explorer 资源管理器的一个扩展，为其增加类似谷歌 Chrome 浏览器的多标签页功能。 preview： everything - 速度最快的的文件搜索工具 地址：http://www.voidtools.com/ 简介：Locate files and folders by name instantly. preview： FastStone Capture 地址：https://faststone-capture.en.softonic.com/ 简介：Image viewer, editor and screen capture preview： autohotkey - win 下效率神器 地址：https://autohotkey.com/ 简介：Powerful. Easy to learn. The ultimate automation scripting language for Windows. BaiduPanDownloadWinform - 百度网盘不限速下载工具 地址：https://github.com/Accelerider/BaiduPanDownloadWinform/releases 简介：百度网盘不限速下载工具 preview： TeamViewer - 远程支持、远程访问、在线协作和会议 地址：https://www.teamviewer.com/zhCN/ 简介：远程桌面控制，个人免费。 如果您回到家后想连接控制在学校或公司里自己的电脑，TeamViewer无疑就是最佳的解决方案 preview： Snipaste - 开发了三年的截图工具，但不只是截图 地址: https://zh.snipaste.com/download.html 简介: Snipaste，顾名思义， Snip + Paste，截图 + 贴图。使用参考：开发了三年的截图工具，但不只是截图 preview： Listary - Windows 文件浏览增强工具 地址: http://www.listary.com/ 简介: 笨拙的文件管理系统是否减慢了你的工作流程？那就是用 Listary 吧！ preview： 未完待续……","tags":[{"name":"tool","slug":"tool","permalink":"https://wencaizhang.gitee.io/tags/tool/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"tool","slug":"oh-my-article/tool","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/tool/"}]},{"title":"解决 Invalid Host header 问题","date":"2017-11-24T12:20:53.000Z","path":"wiki/oh-my-article/vue/05-webpack项目开发环境访问时提示：Invalid Host header/","text":"执行命令 npm run dev 启动本地服务器之后，发现只能在本地访问，不能通过局域网ip和服务器域名来访问。 在项目的根目录的 package.json 文件中的 dev 命令字段中添加 --host 192.168.1.5（本机 ip 地址）。 这样就能通过 ip 访问了，但是通过服务器域名访问时会显示 Invalid Host header，这是由于新版 webpack-dev-server 出于安全考虑，默认检查 hostname，如果 hostname 不是配置内的，将中断访问。 解决办法是在 build 目录中的 webpack.base.config.js 中添加如下 webpack-dev-server 配置： 123devServer: &#123; disableHostCheck: true,&#125;","tags":[{"name":"vue","slug":"vue","permalink":"https://wencaizhang.gitee.io/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"https://wencaizhang.gitee.io/tags/webpack/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"vue","slug":"oh-my-article/vue","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/vue/"}]},{"title":"vue 全局公用函数","date":"2017-11-24T12:20:53.000Z","path":"wiki/oh-my-article/vue/05-vue全局公用函数/","text":"如果你需要让一个工具函数在每个组件可用，可以把方法挂载到 Vue.prototype 上。 你可以选择挂载到 Vue 上，但是这样就需要在使用之前 import Vue form &#39;vue&#39;，而挂载到 prototype 上是为了方便组件内直接用 this.$fn 来使用（$fn 即挂载的全局函数）。 你也可以直接用 Vue.prototype.$fn，这样同样可以全局使用，不过在组件内就需要再 import 一次 Vue 了。 参考：vue 全局公用函数 注册函数 一般建议函数名使用 $ 前缀。像 vue-router 的 $route 和 $router。 入口文件 main.js 中： 1Vue.prototype.$fn = function () &#123;&#125; 组件中使用12345export default &#123; created () &#123; this.$fn() &#125;&#125; 应用实例可以将全局提示、loading等常用功能挂载到全局方便调用，可参考 element-ui的message组件","tags":[{"name":"vue","slug":"vue","permalink":"https://wencaizhang.gitee.io/tags/vue/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"vue","slug":"oh-my-article/vue","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/vue/"}]},{"title":"vue 项目中操作 dom","date":"2017-11-24T12:20:53.000Z","path":"wiki/oh-my-article/vue/06-Vue点击button使input获取焦点/","text":"在某些时候我们希望点击一个按钮可以让输入框获取焦点，但是 Vue 中不建议直接操作 DOM 元素，这时候可以利用 Vue 提供的 ref 属性来实现。 vue-refs: 一个对象，持有注册过 ref 特性 的所有 DOM 元素和组件实例。 在 input 上面绑定属性 ref=&quot;content&quot;，然后就可以通过 this.$refs.content 获取到对应的 input 的 dom 元素。 代码如下： HTML12&lt;input type=\"text\" ref=\"content\" /&gt;&lt;button @click=\"clickHandler\"&gt;Button&lt;/button&gt; VUE12345methods: &#123; clickHandler()&#123; this.$refs.content.focus() &#125;&#125;","tags":[{"name":"vue","slug":"vue","permalink":"https://wencaizhang.gitee.io/tags/vue/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"vue","slug":"oh-my-article/vue","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/vue/"}]},{"title":"React 点击事件为什么没有被触发？","date":"2017-11-19T12:20:53.000Z","path":"wiki/oh-my-article/js/old/react-event/","text":"点击事件可以说是最常用的事件了，但我在使用中却经常按照我的设想触发。Why? 问题描述关键代码如下所示，Title 是一个标题组件，我希望在点击此组件时，执行 handleClick 方法。 但实际上，点击标题时 handleClick 方法并没有被执行。Why?12345678910111213class Container extends Component &#123; handleClick() &#123; console.log('click on container') &#125; render() &#123; return ( &lt;div className=\"container\"&gt; &lt;Title onClick=&#123; this.handleClick.bind(this) &#125;/&gt; &lt;/div&gt; ); &#125;&#125; 原因Title 是 react 组件，并不是一个真实的DOM元素，它不存在点击事件，因为它不是最终渲染的页面的元素。 所有的事件处理函数都必须要绑定到真实的 DOM 上。传给组件，组件只会认为它是个 props。 解决办法有两种 如果 Title 是自定义组件，可以修改组件内部，监听点击事件，通过 props 执行 handleClick 方法，代码如下： 123456789class Title extends Component &#123; render() &#123; return ( &lt;div onClick=&#123; this.props.onClick &#125; className=\"title\"&gt; &lt;h1&gt;React&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125; 如果 Title 是第三方组件，可以在 Title 组件外部包裹一层 DOM 元素，在 DOM 元素上监听点击事件。 12345678910111213class Container extends Component &#123; handleClick() &#123; console.log('click on container') &#125; render() &#123; return ( &lt;div className=\"container\"&gt; &lt;div onClick=&#123; this.handleClick.bind(this) &#125;&gt;&lt;/div&gt;&lt;Title/&gt;&lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 最后，文档是个好东西，文档地址","tags":[{"name":"javascript","slug":"javascript","permalink":"https://wencaizhang.gitee.io/tags/javascript/"},{"name":"react","slug":"react","permalink":"https://wencaizhang.gitee.io/tags/react/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"js","slug":"oh-my-article/js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/"},{"name":"old","slug":"oh-my-article/js/old","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/old/"}]},{"title":"React 中阻止事件冒泡","date":"2017-11-19T12:20:53.000Z","path":"wiki/oh-my-article/todoxxx/react-stop-propagation/","text":"react 和原生 JavaScript 阻止事件冒泡的方式是否相同？TODO 问题描述1234567???e.preventDefault(); // 方法阻止元素发生默认的行为（例如，当点击提交按钮时阻止对表单的提交）。但不阻止事件的冒泡传播e.stopPropagation() // 阻止事件的冒泡传播，但不阻止其默认行为returne false; // 阻止两者e.preventDefault();e.stopPropagation();e.nativeEvent.stopImmediatePropagation(); 原因解决办法","tags":[{"name":"javascript","slug":"javascript","permalink":"https://wencaizhang.gitee.io/tags/javascript/"},{"name":"react","slug":"react","permalink":"https://wencaizhang.gitee.io/tags/react/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"todoxxx","slug":"oh-my-article/todoxxx","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/todoxxx/"}]},{"title":"React 点击事件为什么没有被触发？","date":"2017-11-19T12:20:53.000Z","path":"wiki/oh-my-article/todoxxx/react-event/","text":"点击事件可以说是最常用的事件了，但我在使用中却经常按照我的设想触发。Why? 问题描述关键代码如下所示，Title 是一个标题组件，我希望在点击此组件时，执行 handleClick 方法。 但实际上，点击标题时 handleClick 方法并没有被执行。Why?12345678910111213class Container extends Component &#123; handleClick() &#123; console.log('click on container') &#125; render() &#123; return ( &lt;div className=\"container\"&gt; &lt;Title onClick=&#123; this.handleClick.bind(this) &#125;/&gt; &lt;/div&gt; ); &#125;&#125; 原因Title 是 react 组件，并不是一个真实的DOM元素，它不存在点击事件，因为它不是最终渲染的页面的元素。 所有的事件处理函数都必须要绑定到真实的 DOM 上。传给组件，组件只会认为它是个 props。 解决办法有两种 如果 Title 是自定义组件，可以修改组件内部，监听点击事件，通过 props 执行 handleClick 方法，代码如下： 123456789class Title extends Component &#123; render() &#123; return ( &lt;div onClick=&#123; this.props.onClick &#125; className=\"title\"&gt; &lt;h1&gt;React&lt;/h1&gt; &lt;/div&gt; ); &#125;&#125; 如果 Title 是第三方组件，可以在 Title 组件外部包裹一层 DOM 元素，在 DOM 元素上监听点击事件。 12345678910111213class Container extends Component &#123; handleClick() &#123; console.log('click on container') &#125; render() &#123; return ( &lt;div className=\"container\"&gt; &lt;div onClick=&#123; this.handleClick.bind(this) &#125;&gt;&lt;/div&gt;&lt;Title/&gt;&lt;/div&gt; &lt;/div&gt; ); &#125;&#125; 最后，文档是个好东西，文档地址","tags":[{"name":"javascript","slug":"javascript","permalink":"https://wencaizhang.gitee.io/tags/javascript/"},{"name":"react","slug":"react","permalink":"https://wencaizhang.gitee.io/tags/react/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"todoxxx","slug":"oh-my-article/todoxxx","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/todoxxx/"}]},{"title":"微代码","date":"2017-11-19T12:20:53.000Z","path":"wiki/oh-my-article/todoxxx/micro-code/","text":"常用代码段，样式代码为主。 光标形状 小手 cursor: pointer; 等待 cursor: wait; C3属性 禁用 onclick 事件CSS3 pointer-events:none应用举例及扩展 point-events: auto; 网页被选中文字的背景颜色1234::selection &#123; background-color: green; color: pink;&#125; 修改placeholder文本的样式12345input::-webkit-input-placeholder &#123; color: #ccc; letter-spacing: 2px; font-size: 20px;&#125; 文本间距letter-spacing: 2px; 去掉 input 的外边线outline: none; select 的 option 选项文本默认左对齐，通过以下是属性设置居中12345select &#123; text-align: center; /* 单独一个 text-align 没有效果 */ text-align-last: center;&#125; 点击自身以外的地方，关闭弹出层(待定)12345$(\"body\").click(function() &#123; if($(\".ele\"))&#123; $(\".ele\").hide(); &#125;&#125;) 移动端的问题 iOS/安卓默认样式的不同，如select、a链接 font-size 小于 10px 时候，height 等于 line-height 无法将单行文本居中 input 和 fixed定位的冲突 Web移动端Fixed布局的解决方案 图片 长度单位(px/em/rem) 原生组件样式设置问题，如 input主要思路为隐藏原生组件的样式，设置 label 标签的样式 或者是通过定位、不透明度和层级等属性将原生组件和自定义样式的 div 位置重合，做一个样式的障眼法 禁止用户选中文本12345678div &#123; -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;&#125; 多余文本显示省略号1234width: 100px; /* 固定宽度 */overflow: hidden;white-space: nowrap;text-overflow: ellipsis; 双伪元素清除浮动12345678.clearfix:after, .clearfix:before &#123; content: \"\"; display: table; clear: both;&#125;.clearfix &#123; zoom: 1;&#125; 伪元素清除浮动1234567891011.clearfix:after &#123; content:\"\"; height: 0; line-height: 0; display: block; visibility:hidden; clear:both;&#125;.clearfix &#123; zoom: 1;/*用来兼容ie浏览器*/&#125;","tags":[{"name":"code","slug":"code","permalink":"https://wencaizhang.gitee.io/tags/code/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"todoxxx","slug":"oh-my-article/todoxxx","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/todoxxx/"}]},{"title":"近期用到的 jQuery 方法整理","date":"2017-05-27T14:22:53.000Z","path":"wiki/oh-my-article/js/some-function-of-jquery/","text":"好久不用 jQuery，已经快忘得差不多了。最近用 jQuery 写了不少页面，趁机总结一下。毕竟，好记性不如烂笔头。 一、选择器部分 $(&quot;input[type=&#39;radio&#39;]&quot;) 选择不同 type 的 input $(&quot;input[type=&#39;radio&#39;]:checked&quot;) 选择被选中的 radio 选择父类元素 $ele.parent(&#39;td&#39;) 仅限于直接父类元素 parent $ele.parents(&#39;.content&#39;) 只要是父类元素即可，能向父级多级查找 parents 选择子类元素 $ele.children(&#39;p.tip&#39;); $ele.find(&#39;textarea&#39;) 选择兄弟元素 $ele.parent(&#39;td&#39;).siblings(&#39;.title&#39;) 二、插入和删除元素1. 插入 在被选元素的结尾插入内容 $ele.append(&quot;&lt;p class=&#39;tip red&#39;&gt; &amp;nbsp;&amp;nbsp;请选择&lt;/p&gt;&quot;); 在被选元素的开头插入内容 $ele.prepend(&quot;&lt;span class=&#39;red star&#39;&gt;*&amp;nbsp;&lt;/span&gt;&quot;); 在被选元素之前插入内容 $ele.before($(&#39;.milestone&#39;)); 在被选元素之后插入内容 $ele.after($(&#39;.milestone&#39;)); 2. 删除 remove() 删除被选元素（及其子元素），可传入参数（选择器）作为过滤条件 $ele.remove() 或 $ele.remove(&quot;.italic&quot;); empty() 删除被选元素的子元素 $ele.empty() 三、设置元素样式四、动画1. animate 动画使用固定值123$ele.animate(&#123; top: \"60px\"&#125;) 2. animate 动画使用相对值123$ele.animate(&#123; top: \"-=60px\"&#125;) 3. 判断当前是否有动画尚未执行完毕 如果正在执行动画返回 true $ele.is(&quot;:animated&quot;) 五、获取和设置元素的值 获取文本域的输入的内容 var $val = $ele.val(); 获取属性值 var id = $ele.attr(&#39;id&#39;); 六、其他的一些方法 清空被选中的 radio $(&quot;input[type=&#39;radio&#39;]&quot;).removeAttr(&#39;checked&#39;); 判断 radio 是否被选中 $(this).is(&quot;:checked&quot;) 判断元素是否具有指定的类名 $(this).hasClass(&quot;bad&quot;) jQuery 对象有 length 属性，该属性表示选中的 DOM 元素的个数 if($radiosChecked.length != 2) {} 判断选中元素是否为 display:none 状态 if(!$(this).is(&quot;:hidden&quot;)) {} 序列化表单数据，用于 ajax 提交表单数据 $(&#39;form&#39;).serialize() 输入框失去焦点 $(&#39;input&#39;).blur(function () {});","tags":[{"name":"javascript","slug":"javascript","permalink":"https://wencaizhang.gitee.io/tags/javascript/"},{"name":"jquery","slug":"jquery","permalink":"https://wencaizhang.gitee.io/tags/jquery/"}],"categories":[{"name":"oh-my-article","slug":"oh-my-article","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/"},{"name":"js","slug":"oh-my-article/js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-article/js/"}]},{"title":"git branch --set-upstream 本地分支关联远程分支","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-git/02-常见问题/01-本地分支关联远程分支/","text":"在创建新分支后，使用 git pull 的时候多次碰见下面的情况： git pull 命令并未更新代码，而是打印出了这么一段文字。 123456789There is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details. git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/&lt;branch&gt; release/1.0.0 其实，输出的提示信息说的还是比较明白的，即当前（本地）分支并未关联远程分支，因此在 git pull 或者 git push 时需要显式指定关联的远程分支，如果既没有关联远程分支，也没有在操作时指定远程分支，则会打印如上信息。 因此，有两种解决方法。一种是在 git pull 时指定远程分支，命令如下： 1git pull origin release/1.0.0 使用这种方法需要在每一次 git pull 和 git push 时指定对应的远程分支，略感麻烦，因此我使用第二种方法。 第二种方法则将本地分支与远程分支建立关联，命令如下： 1git branch --set-upstream-to=origin/release/1.0.0 release/1.0.0 其中，origin/release/1.0.0 是本地分支对应的远程分支，release/1.0.0 当前的本地分支。","tags":[{"name":"git","slug":"git","permalink":"https://wencaizhang.gitee.io/tags/git/"}],"categories":[{"name":"oh-my-git","slug":"oh-my-git","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/"},{"name":"02-常见问题","slug":"oh-my-git/02-常见问题","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/02-常见问题/"}]},{"title":"查看修改和撤销修改","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-git/01-基本命令/06-查看修改和撤销修改/","text":"一、已修改，未暂存（1）查看修改只是简单的进行了文件修改，但是还没有做 git add 之前，希望检查一下做了哪些修改： 1git diff 如果只想要检查某个文件做了哪些修改： 1git diff &lt;file-name&gt; （2）撤销修改1git checkout . 或者 1git reset --hard 如果想要撤销指定文件： 1git checkout &lt;file-name&gt; 二、已暂存，未提交（1）查看修改把文件提交到暂存区，即执行 git add . 之后，然后执行 git diff，此时是没有任何结果的。 此时需要加一个参数： 1234567git diff --cached``` ### （2）撤销修改```bashgit resetgit checkout . 三、已提交，未推送（1）查看修改（2）撤销修改既执行了 git add .，又执行了 git commit，这时候你的代码已经进入了你的本地仓库。 1git reset --hard origin master 四、已推送（1）查看修改（2）撤销修改需要先恢复本地仓库，再强制push到远程仓库 12git reset --hard HEAD^git push -f 这种方法不会留下提交记录，如果在某个地方在撤销之前已经拥有最新代码，需要将其退回被恢复版本之前，然后更新代码。 参考文章：Git 的 4 个阶段的撤销更改：http://blog.jobbole.com/113097/","tags":[{"name":"git","slug":"git","permalink":"https://wencaizhang.gitee.io/tags/git/"}],"categories":[{"name":"oh-my-git","slug":"oh-my-git","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/"},{"name":"01-基本命令","slug":"oh-my-git/01-基本命令","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/01-基本命令/"}]},{"title":"Git子模块","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-git/01-基本命令/07-子模块/","text":"添加子模块1git submodule add url@git 克隆含有子模块的项目克隆一个含有子模块的项目时，默认会包含该子模块目录，但其中还没有任何文件： 1$ git clone url@git 使用 --recursive 参数，它就会自动初始化并更新仓库中的每一个子模块。 1$ git clone --recursive url@git userful linkGit 工具 - 子模块","tags":[{"name":"git","slug":"git","permalink":"https://wencaizhang.gitee.io/tags/git/"}],"categories":[{"name":"oh-my-git","slug":"oh-my-git","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/"},{"name":"01-基本命令","slug":"oh-my-git/01-基本命令","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/01-基本命令/"}]},{"title":"临时切换分支","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-git/02-常见问题/03-工作进行一半需切换到另一分支/","text":"问题场景项目发布上线之后，除了正常的迭代更新（release 分支）之外，还需要随时修复发生的重大 bug（hotfix 分支）。 Useful Link3 Git 工具 - 储藏（Stashing）","tags":[{"name":"git","slug":"git","permalink":"https://wencaizhang.gitee.io/tags/git/"}],"categories":[{"name":"oh-my-git","slug":"oh-my-git","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/"},{"name":"02-常见问题","slug":"oh-my-git/02-常见问题","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/02-常见问题/"}]},{"title":"Git 乱码","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-git/02-常见问题/02-git乱码问题/","text":"在 Linux 如果要提交的文件名是中文的，使用 git status 或者 git commit 的时候就会把中文显示为一串数字如下： 1create mode 100644 \"\\346\\265\\213\\350\\257\\225\" 解决方案此时只需要添加相应的配置即可显示正常的中文。 方法一：执行命令1git config --global core.quotepath false 方法二：修改配置手动更改 Git 配置文件 ~/.gitconfig，编辑添加如下内容： 12[core] quotepath = false","tags":[{"name":"git","slug":"git","permalink":"https://wencaizhang.gitee.io/tags/git/"}],"categories":[{"name":"oh-my-git","slug":"oh-my-git","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/"},{"name":"02-常见问题","slug":"oh-my-git/02-常见问题","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/02-常见问题/"}]},{"title":"修改commit信息","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-git/02-常见问题/04-修改commit信息/","text":"amend: vi.&amp;vt. 修改，修订。 如果要修改最近一次 commit 信息，且这次 commit 尚未 push 到远程，可以通过参数 --amend 直接进行修改： 1git commit --amend -m \"your message\"","tags":[{"name":"git","slug":"git","permalink":"https://wencaizhang.gitee.io/tags/git/"}],"categories":[{"name":"oh-my-git","slug":"oh-my-git","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/"},{"name":"02-常见问题","slug":"oh-my-git/02-常见问题","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/02-常见问题/"}]},{"title":"Git基本工作流程","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-git/03-Git实践/01-Git基本工作流程/","text":"代码仓库已经存在 拉取代码： 1git pull &lt;git-repo-url&gt; 修改代码，不多说。 暂存 1git add . 提交本地仓库 1git commit 推送远程仓库 1git push","tags":[{"name":"git","slug":"git","permalink":"https://wencaizhang.gitee.io/tags/git/"}],"categories":[{"name":"oh-my-git","slug":"oh-my-git","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/"},{"name":"03-Git实践","slug":"oh-my-git/03-Git实践","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/03-Git实践/"}]},{"title":"Git最佳实践","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-git/03-Git实践/02-Git最佳实践/","text":"一、git 最佳实践的理论基础 参照英文原版 A successful Git branching model 或者中文翻译 基于git的源代码管理模型——git flow 来理解整个版本管理的流程。 版本管理流程模型如下 具体开发中的应用场景说明 在正常开发状态（非版本发布状态）下， 代码库将仅存在两个分支 master 分支 和 develop 分支，开发人员将相关任务的 commit 提交至 develop 分支，每个 commit 提交需要在提交注释中附加相关修改说明以及 JIRA中对应项目 下相关的任务编号如”SPMS-100“。 在版本测试发布状态（sprint开发结束需要测试发布新的版本）下， 代码库将存在 develop 分支， master 分支以及 release 分支。其中 release 分支由 develop 分支代码派生，由将供测试人员部署在不同的测试环境进行测试，在测试中发现的缺陷，开发人员需在 release 分支中进行修复并合并回 develop 分支。 在版本发布上线状态（release分支通过测试）下， 代码库将存在 develop 分支， master 分支以及 release 分支。其中 release 分支需要合并回 master 分支和 develop 分支，并在 master 分支创建tag，然后将 master 分支发布至生产服务器，且删除 release 分支。 在版本发布上线观察维护状态（master分支发布至生产环境）下， 代码库将存在 develop 分支， master 分支。如果在线上发现有需要立即修复的缺陷，此时需要由 master 分支最新的一个tag中的代码派生出 hotfix 分支，在缺陷修复并且测试通过后，该 hotfix 分支将被合并回 develop 分支和 master 分支，并在 master 分支创建tag，然后将 master 分支发布至生产服务器，且删除 hotfix 分支。 分支说明 develop 分支是保存当前最新开发成果的分支，用于提交相关完成开发任务的commit。 master 分支存放的应该是随时可供在生产环境中部署的代码（Production Ready state），在每个sprint结束（或者hotfix结束）且相关的代码发布后将会被更新。每个稳定的发布版本需要在该分支创建一个tag，tag名称为对应的版本号，如1.0.0；每个hotfix的发布版本也需要在该分支创建一个tag，tag名称为对应的版本号，如1.0.1。 release 分支是为发布新的产品版本而设计的，用于保存测试过程中可能出现的修复代码提交。 hotfix 分支是为修复生产代码中的缺陷而设计的（非sprint），由master 分支最新的一个 tag 中的代码派生。 基于git的源代码管理模型——git flow 中提到的 features 分支不提交保存到 git 服务器，由开发人员在本地进行操作，在此不再赘述。 git操作参考关于git，网上有很多内容，详略程度各有不同，下面列出几个比较简单的入门内容供参考 git参考手册 Getting Git Right Git 风格指南 git-flow参考文档 Using git-flow to automate your git branching workflow Git flow cheatsheet Git-flow Installation Git-flow 备忘清单 基于git的源代码管理模型——git flow git小技巧 git切换分支保存修改的代码的方法 Git远程操作详解 A successful Git branching model","tags":[{"name":"git","slug":"git","permalink":"https://wencaizhang.gitee.io/tags/git/"}],"categories":[{"name":"oh-my-git","slug":"oh-my-git","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/"},{"name":"03-Git实践","slug":"oh-my-git/03-Git实践","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/03-Git实践/"}]},{"title":"Array.prototype.concat()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/01-Array-ES3/01-Array.concat/","text":"描述方法 concat() 将创建并返回一个新数组，这个方法将所有参数都添加到新数组中。它并不修改原数组 。如果要进行 concat() 操作的参数是一个数组，那么添加的是数组中的元素，而不是数组。 参数 参数 描述 valueX 必需。可以使具体的值，也可以是数组对象，可以是任意多个。 返回值一个新数组 示例 参数为具体的值 123var arr = [ 1, 2 ];arr.concat(4, 5); // [ 1, 2, 4, 5 ] 参数为数组对象 123var arr = [ 1, 2 ];arr.concat([4, 5]); // [ 1, 2, 4, 5 ] 多个参数 123var arr = [ 1, 2 ];arr.concat([4, 5], [6, 7]); // [ 1, 2, 4, 5, 6, 7 ] 参数为数组对象，且元素也为数组对象 123var arr = [ 1, 2 ];arr.concat(4, [ 5, [ 6, 7] ]); // [ 1, 2, 4, 5, [ 6, 7 ] ] 模拟实现12345678910111213141516171819/** 模拟原生 Array.concat()*/Array.prototype.concat = function () &#123; var args = arguments; var arr = this; for ( var i = 0; i &lt; args.length; i++ ) &#123; var item = args[i]; if ( item instanceof Array ) &#123; for( var j = 0; j &lt; item.length; j++ ) &#123; arr.push( item[j] ) &#125; &#125; else &#123; arr.push( item ); &#125; &#125; return arr;&#125;","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es3","slug":"es3","permalink":"https://wencaizhang.gitee.io/tags/es3/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"01-Array-ES3","slug":"oh-my-js/01-Array-ES3","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/01-Array-ES3/"}]},{"title":"Array.prototype.pop()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/01-Array-ES3/04-Array.pop/","text":"描述从一个数组中删除并返回最后一个元素。（修改原数组） 参数无 返回值从数组中删除的元素（当数组为空时返回 undefined） 示例12345var arr = [ 1, 2, 3 ];var delEle= arr.pop(); // 3 [].pop(); // undefined","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es3","slug":"es3","permalink":"https://wencaizhang.gitee.io/tags/es3/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"01-Array-ES3","slug":"oh-my-js/01-Array-ES3","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/01-Array-ES3/"}]},{"title":"Array.prototype.push()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/01-Array-ES3/03-Array.push/","text":"描述将一个或多个元素添加到数组的末尾，并返回新数组的长度（对原数组进行修改） 参数 参数 描述 elementN 必需，个数为至少一个。被添加到数组末尾的元素。 返回值新的 length 属性值。 示例1234var arr = [ 1, 2, 3 ];var newLength1 = arr.push(4); // 4var newLength2 = arr.push(5, 6); // 6","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es3","slug":"es3","permalink":"https://wencaizhang.gitee.io/tags/es3/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"01-Array-ES3","slug":"oh-my-js/01-Array-ES3","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/01-Array-ES3/"}]},{"title":"Array.prototype.join()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/01-Array-ES3/02-Array.join/","text":"描述所有的数组元素都被转化成字符串，再用一个分隔符将这些字符串连接起来。如果元素是 undefined 或者 null，则会被转换成空字符串。 参数 参数 描述 separator 可选。 指定要选的分隔符，如果省略，则使用逗号为分隔符。 返回值一个字符串 示例（1）数组元素为基本类型12345var names = [ '李白', '杜甫', '苏轼' ];names.join(); // \"李白,杜甫,苏轼\"names.join( '、' ); // \"李白、杜甫、苏轼\" （2）数组元素为数组对象12345var arr = [ 1, 2, [ 3, 4 ] ];arr.join(); // \"1,2,3,4\"arr.join('+'); // \"1+2+3,4\" （3）数组元素为对象123var arr = [ 1, 2, &#123; name: 'zwc' &#125; ];arr.join(); // \"1,2,[object Object]\" （4）小结实际上 join() 方法是对数组中每一项元素都进行了 toString() 操作转换成字符串之后进行的拼接。 undefined 和 null 执行 toString() 则会报错，因此将其转化为空字符串 1234567(&#123; type: 'object' &#125;).toString(); // \"[object Object]\"([ 3, 4 ]).toString(); // \"3,4\"(true).toString(); // \"true\"(function () &#123; console.log('hello') &#125;).toString(); // \"function () &#123; console.log('hello') &#125;\" 模拟实现1234567891011121314151617/** 模拟原生 Array.join()*/Array.prototype.join = function () &#123; var sep = arguments &amp;&amp; arguments[0] || ','; var str = ''; for ( var i = 0; i &lt; this.length; i++ ) &#123; var item = this[i]; item === undefined || null ? '' : item; str += sep + item.toString(); &#125; return str.replace(sep, '');&#125;","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es3","slug":"es3","permalink":"https://wencaizhang.gitee.io/tags/es3/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"01-Array-ES3","slug":"oh-my-js/01-Array-ES3","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/01-Array-ES3/"}]},{"title":"Array.prototype.shift()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/01-Array-ES3/05-Array.shift/","text":"描述从一个数组中删除并返回第一个元素。（修改原数组） 参数无 返回值从数组中删除的元素（当数组为空时返回 undefined） 示例12345var arr = [ 1, 2, 3 ];var delEle = arr.shift(); // 1 [].shift(); // undefined","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es3","slug":"es3","permalink":"https://wencaizhang.gitee.io/tags/es3/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"01-Array-ES3","slug":"oh-my-js/01-Array-ES3","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/01-Array-ES3/"}]},{"title":"Array.prototype.unshift()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/01-Array-ES3/06-Array.unshift/","text":"描述将一个或多个元素添加到数组的开头，并返回新数组的长度。（修改原数组） 参数 参数 描述 elementN 必需，个数为至少一个。要添加到数组开头的元素 返回值从数组中删除的元素（当数组为空时返回 undefined） 示例123456789101112[].unshift(); // undefinedvar arr = [ 1, 2, 3 ];var newLength1 = arr.unshift(4); // 4 console.log( arr ); // [ 4, 1, 2, 3 ]var newLength2 = arr.unshift(5, 6); // 6 console.log( arr ); // [ 5, 6, 4, 1, 2, 3 ]var newLength3 = arr.unshift([7, 8]); // 7console.log( arr ); // [ [7, 8], 5, 6, 4, 1, 2, 3 ]","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es3","slug":"es3","permalink":"https://wencaizhang.gitee.io/tags/es3/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"01-Array-ES3","slug":"oh-my-js/01-Array-ES3","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/01-Array-ES3/"}]},{"title":"Array.prototype.slice()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/01-Array-ES3/07-Array.slice/","text":"描述不修改原数组，只返回一个浅复制了原数组中的元素的一个新数组。原数组的元素会按照下述规则拷贝： 如果该元素是个对象引用（不是实际的对象）， slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。 对于字符串、数字和布尔值来说（不是 String、Number 和 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或者数字或者布尔值，将不会影响另一个数组。 如果向两个数组中任一一个数组中添加了新元素，则另一个不会受到影响。 参数begin（可选）从该索引处开始提取原数组中的元素。如果该参数为负数，则表示从原数组中的倒数第几个开始提取，slice(-2) 表示提取原数组中的倒数第二个元素到最后一个元素（包含最后一个元素）。如果省略 begin ，则 slice 从索引 0 开始。 end （可选）在该索引处结束提取原数组元素，slice 会提取原数组中索引从 begin 到 end 的所有元素（包含 begin，但不包含 end） slice(1, 4) 提取原数组中的第二个元素开始知道第四个元素的所有元素（索引为 1,2,3 的元素） 如果该参数为负数，则它表示在原数组中的倒数第几个元素结束抽取。slice(-2, -1) 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。 如果 end 被省略，则 slice 会一直提取到原数组末尾。 如果 end 大于数组长度， slice 也会一直提取到原数组末尾。 返回值一个含有提取元素的新数组 示例 省略 begin 和 end 12345678var arr = [ 1, 2, 3 ];var newArr = arr.slice(); // [ 1, 2, 3 ]arr.push( 4 );console.log( arr ); // [ 1, 2, 3, 4 ]console.log( newArr ); // [ 1, 2, 3 ] //TODO…","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es3","slug":"es3","permalink":"https://wencaizhang.gitee.io/tags/es3/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"01-Array-ES3","slug":"oh-my-js/01-Array-ES3","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/01-Array-ES3/"}]},{"title":"Array.prototype.splice()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/01-Array-ES3/08-Array.splice/","text":"描述通过删除现有元素或者添加新元素来更改一个数组的内容 参数start指定修改的开始位置。如果超出了数组的长度，则从数组末尾开始添加内容，如果是负值，则表示从数组末位开始的第几位。 若只使用 start 参数而不使用 deleteCount、item，如：array.splice(start)，表示删除 [start, end] 的元素。 deleteCount （可选）表示要移除的数组的元素的个数。如果 deleteCount 是 0，则不移除元素。这种情况下，至少应该添加一个新元素。如果 deleteCount 大于 start 之后的元素的总数，则从 start 后面的元素豆浆被删除（含第 start 位）。 如果 deleteCount 被省略，则相当于 arr.lengtrh-start。 item1, item2, ... （可选）要添加进数组的元素，从 start 位置开始，如果不指定，则 splice 将只删除数组元素。 返回值由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含了一个元素的数组，如果没有删除元素，则返回空数组。 示例 只有 start 12345var arr = [ 1, 2, 3 ];arr.splice(2); // [ 3 ]console.log(arr); // [ 1, 2 ] deleteCount 为 0 12345var arr = [ 1, 2, 3 ];arr.splice(1, 0); // []console.log(arr); // [ 1, 2, 3 ] deleteCount 大于 start 之后元素的总和 12345var arr = [ 1, 2, 3, 4 ];arr.splice(1, 4); // [ 2, 3, 4 ]console.log(arr); // [ 1 ] item 12345var arr = [ 1, 2, 3 ];arr.splice(1, 2, 4, 5); // [ 2, 3 ]console.log(arr); // [ 1, 4, 5 ]","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es3","slug":"es3","permalink":"https://wencaizhang.gitee.io/tags/es3/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"01-Array-ES3","slug":"oh-my-js/01-Array-ES3","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/01-Array-ES3/"}]},{"title":"Array.prototype.sort()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/01-Array-ES3/10-Array.sort/","text":"描述对数组的元素进行排序，并返回数组，默认排序顺序是根据字符串 Unicode 码点。（修改原数组） 为了实现排序，sort() 方法会调用每个数组项的 toString() 方法，然后比较得到的字符串，以确定如何排序。 另外，sort() 可以接受一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。 参数 参数 描述 compareFunction function 类型，可选。用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为字符串的各个字符的 Unicode 位点进行排序 返回值返回排序后的数组，原数组已经被排序后的数组代替。 示例一维数组排序 不指定排序方法 1234var scores = [1, 10, 21, 2];scores.sort();console.log(scores); // [ 1, 10, 2, 21 ]// 10 在 2 之前，这是因为在 Unicode 指针顺序中\"10\"在\"2\"之前 升序 1234567var numbers = [4, 2, 5, 1, 3];numbers.sort(function(a, b) &#123; return a - b;&#125;);console.log(numbers); // [ 1, 2, 3, 4, 5 ] 降序 1234567var numbers = [4, 2, 5, 1, 3];numbers.sort(function(a, b) &#123; return b - a;&#125;);console.log(numbers); // [ 1, 2, 3, 4, 5 ] 二维数组排序数组元素为对象，按照对象某个属性对其排序 按照 sortNo 属性从小到大排序：123456789101112131415161718192021222324252627var arr= [ &#123; 'sortNo': 2&#125;, &#123; 'sortNo': 1&#125;, &#123; 'sortNo': 5&#125;, &#123; 'sortNo': 6&#125;, &#123; 'sortNo': 7&#125;, &#123; 'sortNo': 3&#125;, &#123; 'sortNo': 9&#125;, &#123; 'sortNo': 4&#125;, &#123; 'sortNo': 0&#125;];arr.sort(function(a, b)&#123; return a.sortNo - b.sortNo;&#125;);console.log(arr);//输出结果//&#123; 'sortNo': 0&#125;//&#123; 'sortNo': 1&#125;//&#123; 'sortNo': 2&#125;//&#123; 'sortNo': 3&#125;//&#123; 'sortNo': 4&#125;//&#123; 'sortNo': 5&#125;//&#123; 'sortNo': 6&#125;//&#123; 'sortNo': 7&#125;//&#123; 'sortNo': 9&#125; 多条件排序按照 sortNo 属性从小到大排序，如果 sortNo 相同，则按照 sortNo2 从大到小排序： 12345678910111213141516171819202122232425262728293031323334353637var arr= [ &#123; 'sortNo': 2, 'sortNo2': 3&#125;, &#123; 'sortNo': 1, 'sortNo2': 3&#125;, &#123; 'sortNo': 5, 'sortNo2': 3&#125;, &#123; 'sortNo': 6, 'sortNo2': 3&#125;, &#123; 'sortNo': 7, 'sortNo2': 3&#125;, &#123; 'sortNo': 3, 'sortNo2': 4&#125;, &#123; 'sortNo': 3, 'sortNo2': 2&#125;, &#123; 'sortNo': 3, 'sortNo2': 1&#125;, &#123; 'sortNo': 3, 'sortNo2': 3&#125;, &#123; 'sortNo': 8, 'sortNo2': 3&#125;, &#123; 'sortNo': 4, 'sortNo2': 1&#125;, &#123; 'sortNo': 4, 'sortNo2': 2&#125;];arr.sort(function( a, b ) &#123; if (a.sortNo == b.sortNo) &#123; return b.sortNo2 - a.sortNo2; &#125; return a.sortNo - b.sortNo&#125;);console.log(arr);// [// &#123;sortNo: 1, sortNo2: 3&#125;// &#123;sortNo: 2, sortNo2: 3&#125;// &#123;sortNo: 3, sortNo2: 4&#125;// &#123;sortNo: 3, sortNo2: 3&#125;// &#123;sortNo: 3, sortNo2: 2&#125;// &#123;sortNo: 3, sortNo2: 1&#125;// &#123;sortNo: 4, sortNo2: 2&#125;// &#123;sortNo: 4, sortNo2: 1&#125;// &#123;sortNo: 5, sortNo2: 3&#125;// &#123;sortNo: 6, sortNo2: 3&#125;// &#123;sortNo: 7, sortNo2: 3&#125;// &#123;sortNo: 8, sortNo2: 3&#125;// ]","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es3","slug":"es3","permalink":"https://wencaizhang.gitee.io/tags/es3/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"01-Array-ES3","slug":"oh-my-js/01-Array-ES3","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/01-Array-ES3/"}]},{"title":"Array.prototype.reverse()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/01-Array-ES3/09-Array.reverse/","text":"描述reverse() 方法用于颠倒数组中元素的顺序。（修改原数组） 参数无 返回值返回颠倒顺序后的数组。 示例123var numbers = [1, 2, 3, 4];numbers.reverse();console.log(numbers); // [4, 3, 2, 1]","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es3","slug":"es3","permalink":"https://wencaizhang.gitee.io/tags/es3/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"01-Array-ES3","slug":"oh-my-js/01-Array-ES3","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/01-Array-ES3/"}]},{"title":"Array.prototype.forEach()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/02-Array-ES5/01-Array.forEach/","text":"描述forEach() 方法对数组每一项运行给定函数 fn，无返回值。另外，还可以指定函数 fn 的上下文环境（this）。 参数 参数 描述 fn function 类型，必需。数组中每个元素需要调用的函数 context 可选。执行回调时的上下文（this） fn 函数支持 3 个参数，依次是： 遍历的数组元素 对应的元素索引 数组本身 返回值无 示例打印 fn 的参数123456789var arr = [ 'a', 'b', 'c' ];arr.forEach(function(value, index, array) &#123; console.log( value, index, array )&#125;);// a 0 [\"a\", \"b\", \"c\"]// b 1 [\"a\", \"b\", \"c\"]// c 2 [\"a\", \"b\", \"c\"] 指定 fn 中 this 的值123456789101112131415161718192021222324var database = &#123; users: [\"张含韵\", \"江一燕\", \"李小璐\"], sendEmail: function (user) &#123; if (this.isValidUser(user)) &#123; console.log(\"你好，\" + user); &#125; else &#123; console.log(\"抱歉，\"+ user +\"，你不是本家人\"); &#125; &#125;, isValidUser: function (user) &#123; return /^张/.test(user); &#125;&#125;;// 给每个人法邮件database.users.forEach( // database.users 中人遍历 database.sendEmail, // 发送邮件 database // 使用 database 代替 sendEmail 的this);// 结果：// 你好，张含韵// 抱歉，江一燕，你不是本家人// 抱歉，李小璐，你不是本家 forEach 不会遍历被删除的元素12345678910111213var arr = [ 'a', 'b', 'c' ];delete arr[1];console.log(arr); // [ \"a\", , \"c\" ]console.log(arr.length); // 3arr.forEach(function (value, index) &#123; console.log(value, index);&#125;)// a 0// b 2 模拟实现12","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es5","slug":"es5","permalink":"https://wencaizhang.gitee.io/tags/es5/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"02-Array-ES5","slug":"oh-my-js/02-Array-ES5","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/02-Array-ES5/"}]},{"title":"Array.prototype.filter()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/02-Array-ES5/03-Array.filter/","text":"filter: 过滤 描述filter() 方法对数组中每一项运行给定函数 fn ,返回使该函数返回值为 true 的项组成的数组。 参数 参数 描述 fn function 类型，必需。数组中每个元素需要调用的函数 context 可选。执行回调时的上下文（this） fn 函数有三个参数，依次是： 遍历的数组元素 对应的元素索引 数组本身 返回值过滤后的新数组，即令给定函数 fn 返回值为 true 的数组元素组成的新数组。 示例打印 fn 参数值123456789var arr = [ 'a', 'b', 'c' ];arr.filter(function(value, index, array) &#123; console.log( value, index, array )&#125;);// a 0 [\"a\", \"b\", \"c\"]// b 1 [\"a\", \"b\", \"c\"]// c 2 [\"a\", \"b\", \"c\"] fn 返回值如果不是布尔值，则会默认被转换成布尔值1234567var data = [ 0, 1, 2, 3 ];var arrFilter= data.filter(function (item) &#123; return item;&#125;);console.log(arrFilter); // [ 1, 2, 3 ] 模拟实现12345678Array.prototype.filter = function (fn, context) &#123; var arr = []; for (var i = 0; i &lt; this.length; i++) &#123; var bool = fn.call(context, this[i], i, this); if (bool) arr.push(this[i]); &#125; return arr;&#125;","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es5","slug":"es5","permalink":"https://wencaizhang.gitee.io/tags/es5/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"02-Array-ES5","slug":"oh-my-js/02-Array-ES5","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/02-Array-ES5/"}]},{"title":"Array.prototype.map()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/02-Array-ES5/02-Array.map/","text":"map: 映射 描述map() 方法对数组中每一项运行给定函数 callback ，返回值是每次 callback 函数调用的结果组成的数组。 另外可以指定函数 callback 的上下文环境（this）。 使用 map() 方法处理数组时，数组元素的范围是在 callback 方法第一次调用之前就已经确定了。 在 map() 方法执行过程中： 原数组新增加的元素将不会被 callback 访问到； 被删除的元素将不会被访问到。 若已经存在的元素被改变或删除了，则它们传递到 callback 的值是 map() 方法遍历到它们的那一时刻的值； 参数 参数 描述 callback function 类型，必需。数组中每个元素需要调用的函数 context 可选。执行回调时的上下文（this） callback 函数支持 3 个参数，依次是： 遍历的数组元素 对应的元素索引 数组本身 返回值返回给定函数 callback 调用的结果组成的数组。 示例打印 callback 参数值123456789var arr = [ 'a', 'b', 'c' ];arr.map(function(value, index, array) &#123; console.log( value, index, array )&#125;);// a 0 [\"a\", \"b\", \"c\"]// b 1 [\"a\", \"b\", \"c\"]// c 2 [\"a\", \"b\", \"c\"] callback 执行时的 this 值默认为 window (或 global)123456789var arr = [ 1, 2, 3 ];this.name = 'name';arr.map(function () &#123; console.log(this.name);&#125;);// name// name// name callback 需要有 return 值，否则会被映射成 undefined123456var data = [ 1, 2, 3 ];// 无 return 值var arrOfSquares = data.map(function (item) &#123;&#125;);console.log(arrOfSquares); // [undefined, undefined, undefined] 求平方1234567var data = [ 1, 2, 3 ];var arrOfSquares = data.map(function (item) &#123; return item * item;&#125;);console.log(arrOfSquares); // [ 1, 4, 9 ] 获取对象数组中的特定属性值们1234567891011var users = [ &#123; name: '张三', age: 18 &#125;, &#123; name: '李四', age: 19 &#125;, &#123; name: '王五', age: 21 &#125;];var names = users.map(function (user) &#123; return user.name;&#125;);console.log(names.join('，')); // 张三，李四，王五 模拟实现12345678910if (typeof Array.prototype.map != 'function') &#123; Array.prototype.map = function (fn, context) &#123; var arr = []; if (typeof fn === 'function') &#123; for (var i = 0, len = this.length; i &lt; len; k++) &#123; arr.push(fn.call(context, this[i], k, this)); &#125; &#125; &#125;&#125;","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es5","slug":"es5","permalink":"https://wencaizhang.gitee.io/tags/es5/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"02-Array-ES5","slug":"oh-my-js/02-Array-ES5","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/02-Array-ES5/"}]},{"title":"Array.prototype.some()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/02-Array-ES5/04-Array.some/","text":"描述some() 方法对数组每一项运行给定函数 fn ，如果该函数对任意一项返回 true ，则 some() 方法返回 true，否则返回 false。 参数 参数 描述 fn function 类型，必需。数组中每个元素需要调用的函数 context 可选。执行回调时的上下文（this） fn 函数有三个参数，依次是： 遍历的数组元素 对应的元素索引 数组本身 返回值如果数组中存在使得给定函数 fn 返回 true 的元素，返回 true ，否则返回 false 。 示例打印 fn 参数值123456789var arr = [ 'a', 'b', 'c' ];arr.some(function(value, index, array) &#123; console.log( value, index, array )&#125;);// a 0 [\"a\", \"b\", \"c\"]// b 1 [\"a\", \"b\", \"c\"]// c 2 [\"a\", \"b\", \"c\"] 如果 fn 返回 true ，则 some() 立即返回 true。1234567891011var arr = [ 'a', 'b', 'c' ];var some = arr.some(function(value, index, array) &#123; console.log( value, index, array ); return value === 'b';&#125;);// a 0 [\"a\", \"b\", \"c\"]// b 1 [\"a\", \"b\", \"c\"]console.log(some); // true fn 返回值如果不是布尔值，则会默认被转换成布尔值1234567891011var data = [ 0, 1, 2, 3 ];var some = data.some(function (item) &#123; console.log(item); return item;&#125;);// 0// 1console.log(some); // true 模拟实现123456789101112Array.prototype.some = function (fn, context) &#123; var arr = this; var fn = fn; var context = context; for(var i = 0; i &lt; arr.length; i++) &#123; var bool = fn.call(context, arr[i], i, arr); if (!!bool) return true; &#125; return false;&#125;","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es5","slug":"es5","permalink":"https://wencaizhang.gitee.io/tags/es5/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"02-Array-ES5","slug":"oh-my-js/02-Array-ES5","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/02-Array-ES5/"}]},{"title":"常用命令","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-git/01-基本命令/01-配置命令/","text":"设置用户名和邮箱设置用户名1git config --global user.name \"your name\" 设置用户邮箱12345678git config --global user.email \"your email\"``` #### 查看用户名```bashgit config user.name 查看邮箱1git config user.email 设置代理设置代理1git config --global http.proxy http://demo.com:8080 查看代理1git config --global --get --global http.proxy 取消代理1git config --global --unset http.proxy 查看git 设置列表信息1git config --global list","tags":[{"name":"git","slug":"git","permalink":"https://wencaizhang.gitee.io/tags/git/"}],"categories":[{"name":"oh-my-git","slug":"oh-my-git","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/"},{"name":"01-基本命令","slug":"oh-my-git/01-基本命令","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/01-基本命令/"}]},{"title":"Array.prototype.every()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/02-Array-ES5/05-Array.every/","text":"描述every() 方法对数组每一项运行给定函数 fn ，如果该函数对每一项都返回 true ，则 every() 方法返回 true，否则返回 false。 参数 参数 描述 fn function 类型，必需。数组中每个元素需要调用的函数 context 可选。执行回调时的上下文（this） fn 函数有三个参数，依次是： 遍历的数组元素 对应的元素索引 数组本身 返回值如果数组中每一项都使得给定函数 fn 返回 true，则 every() 方法返回 true ，否则返回 false 。 示例打印 fn 参数值123456789var arr = [ 'a', 'b', 'c' ];arr.every(function(value, index, array) &#123; console.log( value, index, array )&#125;);// a 0 [\"a\", \"b\", \"c\"]// b 1 [\"a\", \"b\", \"c\"]// c 2 [\"a\", \"b\", \"c\"] 如果 fn 返回 false ，则 every() 立即返回 false。12345678910var arr = [ 'a', 'b', 'c' ];var isEvery = arr.every(function(value, index, array) &#123; console.log( value, index, array ); return value === 'b';&#125;);// a 0 [\"a\", \"b\", \"c\"]console.log(isEvery); // false 模拟实现123456789101112Array.prototype.every = function (fn, context) &#123; var arr = this; var fn = fn; var context = context; for(var i = 0; i &lt; arr.length; i++) &#123; var bool = fn.call(context, arr[i], i, arr); if (!bool) return false; &#125; return true;&#125;","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es5","slug":"es5","permalink":"https://wencaizhang.gitee.io/tags/es5/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"02-Array-ES5","slug":"oh-my-js/02-Array-ES5","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/02-Array-ES5/"}]},{"title":"Array.prototype.lastIndexOf()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/02-Array-ES5/07-Array.lastIndexOf/","text":"描述lastIndexOf() 方法返回在指定元素在数组中的最后一个的索引，如果不存在则返回 -1 。 查找方式为从数组的后面向前查找，从 fromIndex 处开始（使用全等操作符）。 参数 参数 描述 searchElement 要查找的元素 fromIndex 可选。开始查找的位置，在此位置开始从后向前查找。如果该值为负值且绝对值大于或等于数组长度，则返回 -1 。如果参数提供的是一个负值，则将其作为数组末尾的一个抵消，即 -1 表示从最后一个元素开始查找， -2 表示从倒数第二个元素开始查找，以此类推（查找顺序不变，仍然是从后向前查询数组）。默认值为数组长度减 1 ，即整个数组都被查找 。 返回值首个被找到的元素在数组中的索引，若没有找到则返回 -1 。 示例返回首个被查找到的元素的索引12345678var arr = [ 'a', 'b', 'c', 'b', 'a' ];var indexB = arr.lastIndexOf('b');var indexD = arr.lastIndexOf('d');console.log(indexB); // 3 console.log(indexD); // -1 严格相等1234567var arr = [1, 2, 3];var indexStr = arr.lastIndexOf('2');var indexNum = arr.lastIndexOf(2);console.log(indexStr); // -1console.log(indexNum); // 1 使用 fromeIndex 参数1234567var arr = [ 'a', 'b', 'c', 'b', 'a' ];var indexB1 = arr.lastIndexOf('b');var indexB2 = arr.lastIndexOf('b', 2);console.log(indexB1); // 3 console.log(indexB2); // 1 fromIndex 为负值123456789var arr = [ 'a', 'b', 'c', 'b', 'a' ];var index1 = arr.lastIndexOf('a');// -2 表示从倒数第二个元素开始查找var index2 = arr.lastIndexOf('a', -2);console.log(index1); // 4 console.log(index2); // 0 fromIndex 为负值且绝对值大于或等于数组长度，返回 -11234567var arr = [ 'a', 'b', 'c' ];var indexA = arr.lastIndexOf('a', 5);var indexB = arr.lastIndexOf('b', -5);console.log(indexA); // 0 console.log(indexB); // -1 模拟实现1234567891011121314151617181920Array.prototype.lastIndexOf = function (searchElement, fromIndex) &#123; var se = searchElement; var arr = this; var len = arr.length; var fi = parseInt(fromIndex) || len - 1; var i = fi; if (fi &lt; 0 &amp;&amp; -fi &gt;= len) return -1 if (fi &lt; 0) &#123; i = len + fi &#125; for (; i &gt;= 0; i--) &#123; if (arr[i] === se) &#123; return i; &#125; &#125; return -1&#125;","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es5","slug":"es5","permalink":"https://wencaizhang.gitee.io/tags/es5/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"02-Array-ES5","slug":"oh-my-js/02-Array-ES5","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/02-Array-ES5/"}]},{"title":"Array.prototype.reduceRight()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/02-Array-ES5/09-Array.reduceRight/","text":"描述reduceRight() 方法从右向左迭代数组所有项，构建一个最终返回的值。 reduceRight() 方法接收两个参数：一个在每一项上调用的函数和（可选）作为迭代基础的初始值。 参数 参数 描述 fn 迭代时执行的函数 initialValue 可选。当做初次调用 fn 的第一个参数值。 fn 有 4 个参数： 之前值，initialValue 。若缺省 initialValue ，则使用数组第一个元素作为初始值。 当前值，若指定 initialValue ，当前值为数组第一个元素，否则使用数组第二个元素。 索引值，当前值的索引 调用 reduce() 的数组 返回值数组迭代执行 fn 完毕，最后一次执行 fn 的返回值。 示例不指定 initialValue1234567var nums = [ 0, 1, 2, 3, 4 ];var sum = nums.reduce(function ( previous, current, index, array ) &#123; console.log( previous, current, index, array, previous + current ); return previous + current;&#125;)console.log(sum); // 10 函数 fn 被执行 4 次， 每次的参数和返回值如下： previous current index array 返回值 第一次 0 1 1 [0, 1, 2, 3, 4] 1 第二次 1 2 2 [0, 1, 2, 3, 4] 3 第三次 3 3 3 [0, 1, 2, 3, 4] 6 第四次 6 4 4 [0, 1, 2, 3, 4] 10 指定 initialValue1234567var nums = [ 0, 1, 2, 3, 4 ];var sum = nums.reduce(function ( previous, current, index, array ) &#123; console.log( previous, current, index, array, previous + current ); return previous + current;&#125;, 100)console.log(sum); // 110 函数 fn 被执行 5 次， 每次的参数和返回值如下： previous current index array 返回值 第一次 100 0 0 [0, 1, 2, 3, 4] 100 第二次 100 1 1 [0, 1, 2, 3, 4] 101 第三次 101 2 2 [0, 1, 2, 3, 4] 103 第四次 103 3 3 [0, 1, 2, 3, 4] 106 第五次 106 4 4 [0, 1, 2, 3, 4] 110 模拟实现1// TODO","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es5","slug":"es5","permalink":"https://wencaizhang.gitee.io/tags/es5/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"02-Array-ES5","slug":"oh-my-js/02-Array-ES5","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/02-Array-ES5/"}]},{"title":"Array.prototype.reduce()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/02-Array-ES5/08-Array.reduce/","text":"reduce: 减少，缩小。但是 reduce() 方法并无此含义，而是“迭代，递归”。 描述reduce() 方法从左向右迭代数组所有项，构建一个最终返回的值。 reduce() 方法接收两个参数：一个在每一项上调用的函数和（可选）作为迭代基础的初始值。 参数 参数 描述 fn 迭代时执行的函数 initialValue 可选。当做初次调用 fn 的第一个参数值。 fn 有 4 个参数： 之前值，initialValue 。若缺省 initialValue ，则使用数组第一个元素作为初始值。 当前值，若指定 initialValue ，当前值为数组第一个元素，否则使用数组第二个元素。 索引值，当前值的索引 调用 reduce() 的数组 返回值数组迭代执行 fn 完毕，最后一次执行 fn 的返回值。 示例不指定 initialValue1234567var nums = [ 0, 1, 2, 3, 4 ];var sum = nums.reduce(function ( previous, current, index, array ) &#123; console.log( previous, current, index, array, previous + current ); return previous + current;&#125;)console.log(sum); // 10 函数 fn 被执行 4 次， 每次的参数和返回值如下： previous current index array 返回值 第一次 0 1 1 [0, 1, 2, 3, 4] 1 第二次 1 2 2 [0, 1, 2, 3, 4] 3 第三次 3 3 3 [0, 1, 2, 3, 4] 6 第四次 6 4 4 [0, 1, 2, 3, 4] 10 指定 initialValue1234567var nums = [ 0, 1, 2, 3, 4 ];var sum = nums.reduce(function ( previous, current, index, array ) &#123; console.log( previous, current, index, array, previous + current ); return previous + current;&#125;, 100)console.log(sum); // 110 函数 fn 被执行 5 次， 每次的参数和返回值如下： previous current index array 返回值 第一次 100 0 0 [0, 1, 2, 3, 4] 100 第二次 100 1 1 [0, 1, 2, 3, 4] 101 第三次 101 2 2 [0, 1, 2, 3, 4] 103 第四次 103 3 3 [0, 1, 2, 3, 4] 106 第五次 106 4 4 [0, 1, 2, 3, 4] 110 模拟实现1// TODO","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es5","slug":"es5","permalink":"https://wencaizhang.gitee.io/tags/es5/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"02-Array-ES5","slug":"oh-my-js/02-Array-ES5","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/02-Array-ES5/"}]},{"title":"Array.isArray()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/02-Array-ES5/10-Array.isArray/","text":"描述Array.isArray() 方法用于确定一个值是否为 Array 类型。 注意：Array.isArray() 方法只能由构造函数 Array 调用，而数组实例无法调用。 ps：严格判断 JavaScript 对象是否为数组 参数 参数 描述 value 需要检测的值 返回值如果被检测的值是 Array 类型，返回 true ，否则返回 false 。 示例1234567891011Array.isArray([]); // trueArray.isArray([1]); // trueArray.isArray(new Array()); // trueArray.isArray(Array.prototype); // trueArray.isArray(); // false Array.isArray(&#123;&#125;); // false Array.isArray(null); // false Array.isArray(undefined); // false Array.isArray(12); // false Array.isArray(true); // false 模拟实现123Array.isArray = function (value) &#123; return Object.prototype.toString.call(value) === '[Object Array]';&#125;","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es5","slug":"es5","permalink":"https://wencaizhang.gitee.io/tags/es5/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"02-Array-ES5","slug":"oh-my-js/02-Array-ES5","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/02-Array-ES5/"}]},{"title":"String.prototype.toLowerCase()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/04-String/001-String.toLowerCase/","text":"描述toLowerCase 会将调用该方法的字符串转为小写形式，并返回。 toLowerCase 不会影响字符串本身。 参数无 返回值一个新的字符串，转换为小写形式之后的字符串。 示例12345var str = 'GitHub'var newStr = str.toLowerCase();console.log(str); // GitHubconsole.log(newStr); // github","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"string","slug":"string","permalink":"https://wencaizhang.gitee.io/tags/string/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"04-String","slug":"oh-my-js/04-String","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/04-String/"}]},{"title":"String.prototype.toUpperCase()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/04-String/002-String.toUpperCase/","text":"描述toUpperCase 会将调用该方法的字符串转为大写形式，并返回。 toUpperCase 不会影响字符串本身。 参数无 返回值一个新的字符串，转换为大写形式之后的字符串。 示例12345var str = 'app'var newStr = str.toUpperCase();console.log(str); // appconsole.log(newStr); // APP","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"string","slug":"string","permalink":"https://wencaizhang.gitee.io/tags/string/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"04-String","slug":"oh-my-js/04-String","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/04-String/"}]},{"title":"Array.prototype.xxx()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/03-Array-ES6/01-Array.from/","text":"描述参数 参数 描述 xxx yyy 返回值示例 1234567```## 模拟实现 ```js","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es6","slug":"es6","permalink":"https://wencaizhang.gitee.io/tags/es6/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"03-Array-ES6","slug":"oh-my-js/03-Array-ES6","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/03-Array-ES6/"}]},{"title":"Array.prototype.find()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/03-Array-ES6/04-Array.find/","text":"描述find 方法用于找出第一个符合条件的数组元素。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找到第一个返回值为 true 的元素，然后返回该元素。如果没有符合条件的元素，则返回 undefined。 参数 参数 描述 callback 数组元素依次执行的回调函数 thisValue 指定 callback 执行的上下文环境，即 this 的值 返回值第一个符合条件的数组元素 示例打印 callback 的参数123456789var arr = [ 'a', 'b', 'c' ];arr.find(function(value, index, array) &#123; console.log(value, index, array);&#125;);// a 0 [\"a\", \"b\", \"c\"]// b 1 [\"a\", \"b\", \"c\"]// c 2 [\"a\", \"b\", \"c\"] find() 的返回值有符合条件的，返回该数组元素，没有符合条件的，返回 undefined 1234567891011var arr = [ 'a', 'b', 'c' ];var result1 = arr.find(function(value, index, array) &#123; return value == 'c'; &#125;);console.log(result1); // \"c\"var result2 = arr.find(function(value, index, array) &#123; return value == 'xyz'; &#125;);console.log(result2); // undefined 找到第一个符合条件的，方法立即结束执行12345678910var arr = [ 'a', 'b', 'b', 'c' ];var result1 = arr.find(function(value, index, array) &#123; console.log(value); return value == 'b'; &#125;);// \"a\"// \"b\"console.log(result1); // \"b\" 指定 callback 执行时的 this 指向1234567var ages = [ 10, 12, 26, 15 ];var person = &#123;name: 'John', age: 20&#125;;var age = ages.find(function (value) &#123; return value &gt; this.age;&#125;, person);console.log(age); // 26","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es6","slug":"es6","permalink":"https://wencaizhang.gitee.io/tags/es6/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"03-Array-ES6","slug":"oh-my-js/03-Array-ES6","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/03-Array-ES6/"}]},{"title":"Array.of()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/03-Array-ES6/02-Array.of/","text":"描述Array.of 方法用于将一组值转换为数组。基本可以用来替代 Array() 或者 new Array()，并且不存在由于参数不同而导致的重载。 参数 参数 描述 arguments 任意值，不限个数。作为数组的元素。 返回值返回由参数值组成的数组。如果没有参数，就返回一个空数组。 示例1234567Array.of(); // []Array.of(undefined); // [ undefined ]Array.of(1); // [ 1 ]Array.of(1, 2); // [ 1, 2 ] 模拟实现123function ArrayOf()&#123; return [].slice.call(arguments);&#125;","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es6","slug":"es6","permalink":"https://wencaizhang.gitee.io/tags/es6/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"03-Array-ES6","slug":"oh-my-js/03-Array-ES6","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/03-Array-ES6/"}]},{"title":"Array.prototype.xxx()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/03-Array-ES6/03-Array.copyWithin/","text":"描述参数 参数 描述 xxx yyy 返回值示例 1234567```## 模拟实现 ```js","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es6","slug":"es6","permalink":"https://wencaizhang.gitee.io/tags/es6/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"03-Array-ES6","slug":"oh-my-js/03-Array-ES6","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/03-Array-ES6/"}]},{"title":"Array.prototype.xxx()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/03-Array-ES6/06-Array.fill/","text":"描述参数 参数 描述 xxx yyy 返回值示例 1234567```## 模拟实现 ```js","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es6","slug":"es6","permalink":"https://wencaizhang.gitee.io/tags/es6/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"03-Array-ES6","slug":"oh-my-js/03-Array-ES6","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/03-Array-ES6/"}]},{"title":"Array.prototype.xxx()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/03-Array-ES6/05-Array.findIndex/","text":"描述参数 参数 描述 xxx yyy 返回值示例 1234567```## 模拟实现 ```js","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es6","slug":"es6","permalink":"https://wencaizhang.gitee.io/tags/es6/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"03-Array-ES6","slug":"oh-my-js/03-Array-ES6","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/03-Array-ES6/"}]},{"title":"Array.prototype.xxx()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/03-Array-ES6/09-Array.values/","text":"描述参数 参数 描述 xxx yyy 返回值示例 1234567```## 模拟实现 ```js","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es6","slug":"es6","permalink":"https://wencaizhang.gitee.io/tags/es6/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"03-Array-ES6","slug":"oh-my-js/03-Array-ES6","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/03-Array-ES6/"}]},{"title":"Array.prototype.xxx()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/03-Array-ES6/07-Array.entries/","text":"描述参数 参数 描述 xxx yyy 返回值示例 1234567```## 模拟实现 ```js","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es6","slug":"es6","permalink":"https://wencaizhang.gitee.io/tags/es6/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"03-Array-ES6","slug":"oh-my-js/03-Array-ES6","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/03-Array-ES6/"}]},{"title":"Array.prototype.includes()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/03-Array-ES6/10-Array.includes/","text":"描述方法 includes 返回一个布尔值，表示某个数组是否包含给定的值。 参数 参数 描述 value 必需。被检测的值 fromIndex Number 类型，可选。表示搜索的起始位置，默认为 0 返回值布尔值，表示某个数组是否包含给定的值。 示例不指定 fromIndex1234const arr = [ 1, 2, 4 ];arr.includes(1); // truearr.includes(3); // false 指定 fromIndex1234const arr = [ 1, 2, 4 ];arr.includes(1, 1); // falsearr.includes(2, 2); // false","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es6","slug":"es6","permalink":"https://wencaizhang.gitee.io/tags/es6/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"03-Array-ES6","slug":"oh-my-js/03-Array-ES6","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/03-Array-ES6/"}]},{"title":"Array.prototype.xxx()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/03-Array-ES6/08-Array.keys/","text":"描述参数 参数 描述 xxx yyy 返回值示例 1234567```## 模拟实现 ```js","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es6","slug":"es6","permalink":"https://wencaizhang.gitee.io/tags/es6/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"03-Array-ES6","slug":"oh-my-js/03-Array-ES6","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/03-Array-ES6/"}]},{"title":"Object.prototype.hasOwnProperty()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/05-Object/01-hasOwnProperty/","text":"描述JavaScript 对象既可以有自己的属性，也可以从原型继承。通过 hasOwnProperty 可以区分继承属性和非继承属性。 参数 参数 描述 prop String 类型，必需。要检测的属性名 返回值布尔值，对象自身是否拥有被检测的属性。 示例判断自身属性 prop 是否存在123456789101112var obj = new Object();obj.prop = 'ok';function changeObj () &#123; obj.newProp = obj.prop; delete obj.prop;&#125;obj.hasOwnProperty('prop'); // truechangeObj();obj.hasOwnProperty('prop'); // false 区分自身属性和继承属性123456var obj = new Object();obj.prop = 'ok';obj.hasOwnProperty('prop'); // trueobj.hasOwnProperty('toString'); // falseobj.hasOwnProperty('hasOwnProperty'); // false 在遍历一个对象所有自身属性时使用注意：for...in 循环只会遍历可枚举属性 1234567891011var obj = new Object();obj.prop = 'ok';Object.prototype.name = 'name';for (var k in obj) &#123; if (obj.hasOwnProperty(k)) &#123; console.log('hasOwnProperty: ', k); &#125; else &#123; console.log('Not hasOwnProperty: ', k); &#125;&#125; hasOwnProperty 被改写1234567891011var obj = &#123; hasOwnProperty: function () &#123; return false; &#125;, prop: 'ok'&#125;;obj.hasOwnProperty('prop'); // 永远都返回 false// 为避免这种情况，可以使用 Object 原型链上的 hasOwnProperty 属性来判断Object.prototype.hasOwnProperty.call(obj, 'prop');","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"object","slug":"object","permalink":"https://wencaizhang.gitee.io/tags/object/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"05-Object","slug":"oh-my-js/05-Object","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/05-Object/"}]},{"title":"Object.assign()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/05-Object/05-Object.assign/","text":"描述ES6 引入 Object.assign 方法，它用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。 参数第一个参数是目标对象，后面的参数都是源对象。 返回值合并之后的目标对象。 示例0. 基本使用12345678const target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);console.log(target); // &#123;a: 1, b: 2, c: 3&#125; 1. 同名属性后面覆盖前面12345678const target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2 , c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);console.log(target); // &#123;a: 1, b: 2, c: 3&#125; 2. 只有一个参数只有一个参数，直接返回该参数 12const obj = &#123; a: 1 &#125;;Object.assign(obj) === obj; // true 如果该参数不是对象，则会先转成对象，然后返回。 1typeof Object.assign(2); // \"object\" 参数是 undefined 或 null，会报错。 12Object.assign(undefined); // 报错Object.assign(null); // 报错 3. 源对象不是 Object 类型如果源对象不是 Object 类型，会先将其转换为对象，如果无法转换，则跳过。 因此，undefined 和 null 不会报错，数字和布尔值也不会报错，会直接跳过，无任何效果。 而字符串会以数组形式拷贝到目标对象。 123456Object.assign(&#123;&#125;, undefined); // &#123;&#125;Object.assign(&#123;&#125;, null); // &#123;&#125;Object.assign(&#123;&#125;, 1); // &#123;&#125;Object.assign(&#123;&#125;, true); // &#123;&#125;Object.assign(&#123;&#125;, 'abcd'); // &#123;0: \"a\", 1: \"b\", 2: \"c\", 3: \"d\"&#125;Object.assign(&#123;&#125;, &#123; a: 1 &#125;); // &#123; a: 1 &#125; 4. assign() 是浅拷贝如果源对象的某个属性值是对象，那么目标对象拷贝得到的是这个对象的引用。 此属性发生任何变化，都会反映到目标对象上。 1234567const obj = &#123; person: &#123; name: 'jack' &#125; &#125;;const obj2 = Object.assign(&#123;&#125;, obj);obj.person.name = 'tom';console.log(obj2.person.name); // \"tom\" 5. 数组的处理Object.assign 可以用来处理数组，但是会把数组视为对象。 1Object.assign([1, 2, 3], [4, 5]); // [4, 5, 3]","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"object","slug":"object","permalink":"https://wencaizhang.gitee.io/tags/object/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"05-Object","slug":"oh-my-js/05-Object","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/05-Object/"}]},{"title":"Object.keys()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/05-Object/02-Object.keys/","text":"描述ES6 引入 Object.keys 方法，它返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。 参数 参数 描述 obj Object 类型，必需。要处理的对象 返回值一个表示给定对象的所有可枚举属性的字符串数组 示例0. 基本使用1234567var arr = &#123; name: 'jack', age: 20, sex: 'man'&#125;;var keys = Object.keys(arr); // [\"name\", \"age\", \"sex\"] 1. 简单数组12var arr = [ 'a', 'b', 'c' ];console.log( Object.keys(arr) ); // [ '0', '1', '2' ] 2. 类数组对象12var obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log( Object.keys(obj) ); // [ '0', '1', '2' ] 3. 随机索引的类数组对象注意顺序，按照索引从小到大进行遍历。 12var anObj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;console.log( Object.keys(anObj) ); // [ '2', '7', '100' ] 4. 包含不可枚举属性123456789var obj = Object.create(&#123;&#125;, &#123; getFoo: &#123; value: function () &#123; return this.foo; &#125; &#125;&#125;);obj.foo = 1;console.log( Object.keys(obj) ); // [ 'foo' ] 5. 异常处理ES5 中，如果参数是原始值，会抛出异常。ES6 中则会强制转化为一个对象。 123Object.keys( 'foo' ); // TypeError: \"foo\" is not an object (ES5 code)Object.keys( 'foo' ); // [ '0', '1', '2' ]","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"object","slug":"object","permalink":"https://wencaizhang.gitee.io/tags/object/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"05-Object","slug":"oh-my-js/05-Object","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/05-Object/"}]},{"title":"Object.values()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/05-Object/03-Object.values/","text":"描述ES6 引入 Object.values 方法，它返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值 参数 参数 描述 obj Object 类型，必需。要处理的对象 返回值数组类型 示例1. 普通对象12var obj = &#123; foo: 'bar', boo: 123 &#125;;console.log( Object.values(obj) ); // [ 'bar', 123 ] 2. 类数组对象12var obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log( Object.values(obj) ); // [ 'a', 'b', 'c' ] 3. 随机索引的类数组对象12var obj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;console.log( Object.values(obj) ); // [ 'b', 'c', 'a' ] 4.5. 异常1Object.values( 'foo' ); // [ 'f', 'o', 'o' ]","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"object","slug":"object","permalink":"https://wencaizhang.gitee.io/tags/object/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"05-Object","slug":"oh-my-js/05-Object","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/05-Object/"}]},{"title":"Object.entries()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/05-Object/04-Object.entries/","text":"描述ES6 引入 Object.entries 方法，它返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。 参数 参数 描述 obj Object 类型，必需。要处理的对象 返回值数组类型 示例1. 普通对象12var obj = &#123; foo: 'bar', boo: 123 &#125;;console.log( Object.entries(obj) ); // [ [\"foo\", \"bar\"], [\"boo\", 123] ] 2. 类数组对象12var obj = &#123; 0: 'a', 1: 'b', 2: 'c' &#125;;console.log( Object.entries(obj) ); // [ [\"0\", \"a\"], [\"1\", \"b\"], [\"2\", \"c\"] ] 3. 随机索引的类数组对象12var obj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;console.log( Object.values(obj) ); // [ [\"2\", \"b\"], [\"7\", \"c\"], [\"100\", \"a\"] ] 4.5. 异常1Object.values( 'foo' ); // [ 'f', 'o', 'o' ]","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"object","slug":"object","permalink":"https://wencaizhang.gitee.io/tags/object/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"05-Object","slug":"oh-my-js/05-Object","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/05-Object/"}]},{"title":"Object.is()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/05-Object/06-Object.is/","text":"描述ES6 引入 Object.assign 方法，它用于比较两个值是否严格相等。 相等运算符（==）会自动转换类型，严格相等运算符 NaN 不等于自身，而且 +0 等于 -0。 Object.is() 方法和严格相等运算符基本一致，不同之处有两个，一是 +0 不等于 -0，二是 NaN 等于自身。 参数两个进行比较的值 返回值如果两个参数相等，返回 true ，否则返回 false 。 示例0. 基本使用123Object.is( &#123;&#125;, &#123;&#125; ); // falseObject.is( 'abc', 'abc' ); // true 1. Object.is() 不会自动转换类型123console.log( '5' == 5 ); // trueconsole.log( Object.is('5', 5) ); // false 2. Object.is() 和 严格相等（===）的区别12345console.log( Object.is( NaN, NaN ) ); // trueconsole.log( NaN === NaN ); // falseconsole.log( Object.is( -1, +1 ) ); // falseconsole.log( +1 === -1)","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"object","slug":"object","permalink":"https://wencaizhang.gitee.io/tags/object/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"05-Object","slug":"oh-my-js/05-Object","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/05-Object/"}]},{"title":"Object.defineProperty()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/05-Object/07-Object.defineProperty/","text":"用法这个方法在一个对象上定义一个新属性，或者修改一个已经存在的属性。并返回这个对象。 1Object.defineProperty(obj, prop, descriptor); obj: 目标对象 prop: 要操作的属性 descriptor: 要操作的属性所拥有的特性 descriptor 用于指定对象属性的特性，这些特性包括： value: 属性的值，默认为 undefined writable: 属性的值是否可以被重写，默认为 true get: 获取属性值的时候触发的函数，默认为 undefined set: 设置属性值的时候触发的函数，默认为 undefined configurable: 是否可以删除目标属性或是否可以再次修改属性的特性，默认为 true enumerable: 此属性是否可以被枚举（使用for…in或Object.keys()），默认为 true 示例修改属性的 value12345678var obj = &#123; name: 'jack', age: 18 &#125;;Object.defineProperty( obj, 'age', &#123; value: 22&#125;);console.log( obj.age ); // 22// age 属性已经被修改 如果对象不存在这个属性，就会创建这个属性 1234567var obj = &#123; name: 'jack' &#125;;Object.defineProperty( obj, 'age', &#123; value: 22&#125;);console.log( obj ); // &#123;name: \"jack\", age: 22&#125; 修改属性的 writable将 writable 设置为 false 。 1234567var obj = &#123; name: 'jack', age: 18 &#125;;Object.defineProperty( obj, 'age', &#123; writable: false&#125;);console.log( obj.age ); // 18 若直接对属性赋值，不起作用，也不报错。 123// 直接对属性赋值，不起作用，也不报错obj.age = 22;console.log( obj.age ); // 18 只能使用 Object.defineProperty 方法修改其值。 12345// 使用 defineProperty 方法修改，修改成功Object.defineProperty( obj, 'age', &#123; value: 22&#125;);console.log( obj.age ); // 22 将 writable 设置为 true 之后可以直接进行赋值 123456Object.defineProperty( obj, 'age', &#123; writable: true&#125;);obj.age = 20;console.log( obj.age ); // 20 enumerableenumerable 用来表示此属性是否可以被枚举（使用 for in 和 Object.keys() ）。 12345678910111213var obj = &#123; name: 'jack', age: 18 &#125;;for (k in obj) &#123; console.log(k, obj[k]);&#125;// name jack// age 18console.log( Object.keys(obj) );// [ \"name\", \"age\" ]console.log( Object.values(obj) );// [ \"jack\", 18 ] 将 enumerable 设置为 false 1234567891011121314Object.defineProperty( obj, 'age', &#123; enumerable: false&#125;)for (k in obj) &#123; console.log(k, obj[k]);&#125;// name jackconsole.log( Object.keys(obj) );// [ \"name\" ]console.log( Object.values(obj) );// [ \"jack\" ] set 和 get先来看 get，get 方法会在获取 age 属性的时候执行，并将其返回值作为 age 属性的值。 12345678910var obj = &#123; name: 'jack', age: 18 &#125;;Object.defineProperty( obj, 'age', &#123; get: function () &#123; return 'get age'; &#125;&#125;)console.log( obj.age );// \"get age\" 再来看 set 1234567891011121314var obj = &#123; name: 'jack', age: 18 &#125;;Object.defineProperty( obj, 'age', &#123; set: function ( newValue ) &#123; console.log( 'newValue:', newValue ) &#125;&#125;);obj.age = 22;console.log( 'age:', obj.age )// newValue: 22// age: undefined set 方法接收一个参数，即将要给 age 设置的新值。 set 方法的返回值是最终 age 属性的值，如果 set 方法没有返回值，则为 undefined。 1234567891011121314var obj = &#123; name: 'jack', age: 18 &#125;;Object.defineProperty( obj, 'age', &#123; set: function ( newValue ) &#123; return newValue; &#125;&#125;);obj.age = 22;console.log( 'age:', obj.age )// newValue: 22// age: undefined","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"object","slug":"object","permalink":"https://wencaizhang.gitee.io/tags/object/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"05-Object","slug":"oh-my-js/05-Object","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/05-Object/"}]},{"title":"正则表达式预查","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/06-Regexp/0-正则表达式预查/","text":"预查格式(?=pattern) 上代码通俗点说，就是 预查不消耗字符串，仅仅是用来确认是否匹配成功。 123456var str = \"abc\";var reg1 = /a(?=b)bc/;var reg2 = /a(b)bc/;console.log(reg1.test(str)); // trueconsole.log(reg2.test(str)); // false reg1 中的预查 (?=b) 并没有消耗掉匹配到的字符 b，而是确认 a 后面的字符是 b，因此 a 后面的字符 bc 和 预查后面的正则 bc 匹配成功，最后结果为 true。 而 reg2 中的 (b) 将 str 中的 b 消耗掉，str 中只剩一个字符 c，无法与 reg2 中 (b) 后面的 bc 相匹配，最后结果为 false。 示例千分制表示一个数字如何给一串数字用千分制表示？比如 99999999999 变成 99, 999, 999, 999。 $&amp; 表示与正则表达式相匹配的字符 123var reg = /\\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+$)/g;var f = '99999999999'.replace(reg, '$&amp;, ');console.log(f); // 99, 999, 999, 999 正则表达式中的 $ 很重要，它保证了每一个匹配到的字符串后面都是三个数字。如果没有 $，会怎样？ 123var reg = /\\d&#123;1,3&#125;(?=(\\d&#123;3&#125;)+)/g;var f = '99999999999'.replace(reg, '$&amp;, ');console.log(f); // 999, 999, 99, 999","tags":[{"name":"regexp","slug":"regexp","permalink":"https://wencaizhang.gitee.io/tags/regexp/"},{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"06-Regexp","slug":"oh-my-js/06-Regexp","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/06-Regexp/"}]},{"title":"正则表达式的 lastIndex 属性","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/06-Regexp/01-Regexp.lastIndex/","text":"描述在每个实例化的正则对象中，都存在一个 lastIndex 属性，初始值为 0 。 lastIndex 属性是进行正则匹配操作的开始的位置 如果正则表达式不带 g 标志，则 lastIndex 始终为 0。 如果正则表达式带有 g 标志，匹配成功则将匹配内容最后一个字符串在原字符串中的索引加 1 设置为 lastIndex 的值，匹配失败则重置为 0。 示例返回值123456789101112var reg1 = /ab/;var reg2 = /ab/g;var str = 'abcabc';console.log(reg1.lastIndex, reg1.test(str)); // 0 trueconsole.log(reg1.lastIndex, reg1.test(str)); // 0 trueconsole.log(reg1.lastIndex, reg1.test(str)); // 0 trueconsole.log(reg2.lastIndex, reg2.test(str)); // 0 trueconsole.log(reg2.lastIndex, reg2.test(str)); // 2 trueconsole.log(reg2.lastIndex, reg2.test(str)); // 5 false// 当 lastIndex 为 5 时，正则匹配从 str[5] 的位置开始，结果为 false","tags":[{"name":"regexp","slug":"regexp","permalink":"https://wencaizhang.gitee.io/tags/regexp/"},{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"06-Regexp","slug":"oh-my-js/06-Regexp","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/06-Regexp/"}]},{"title":"正则表达式","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/06-Regexp/00-Regexp/","text":"正则表达式验证工具： https://regexper.com/ 创建正则表达式构造函数123var reg1 = new RegExp('a');var reg2 = new RegExp('[a-zA-Z]', 'gi');var reg3 = new RegExp(/[a-zA-Z]/, 'gi'); 字面量1var reg = /[a-zA-Z]/gi; 修饰符 修饰符 描述 i 执行对大小写不敏感的匹配 g 执行全局匹配（查找所有匹配，而非在找到第一个匹配后停止） m 执行多行匹配 s 执行单行匹配 正则对象属性 属性均为只读，无法设置其值 属性 含义 默认值 global 是否全文搜索 false ignoreCase 是否大小写敏感 false multiline 多行搜索 false lastIndex 是当前表达式匹配内容的最后一个字符的下一个位置 无 source 正则表达式的文本字符串 无 示例： 123456789101112var reg1 = /\\w/;var reg2 = /\\w/gim;console.log(reg1.global); // falseconsole.log(reg1.ignoreCase); // falseconsole.log(reg1.multiline); // falseconsole.log(reg1.source); // \"\\w\"console.log(reg2.global); // trueconsole.log(reg2.ignoreCase); // trueconsole.log(reg2.multiline); // trueconsole.log(reg2.source); // \"\\w\" 方括号 表达式 描述 [abc] 匹配方括号之间的任何字符 [^abc] 匹配任何不在方括号之间的字符 [0-9] 匹配任何从 0 至 9 的数字 [a-z] 匹配任何从小写 a 到小写 z 的字符 [A-Z] 匹配任何从大写 A 到大写 Z 的字符 [A-z] 匹配任何从大写 A 到小写 z 的字符 [adgk] 匹配给定集合内的任何字符 [^adgk] 匹配给定集合外的任何字符 (red blue green) 匹配任何指定的选项 子表达式用括号括起来的正则表达式。例如： 1234var str = 'hello world';var reg = /(\\w*)\\s*(\\w*)/;var ans = str.replace(reg, '$2 $1')console.log(ans); // world hello 如 /(\\w*)\\s*(\\w*)/ 中，第一个括号 (\\w*) 匹配到的字符串（本例中是 hello），记为 $1，第二个括号 (\\w*) 匹配到的字符串（本例中是 world），记为 $2。 简单地说：从左到右，以分组的左括号为标志，第一个出现的分组的序号为 1，第二个为 2，以此类推。 复杂地说：分组 0 对应整个正则表达式实际上组号分配过程是要从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配－－因此所有命名组的组号都大于未命名的组号。可以使用 (?:exp) 这样的语法来剥夺一个分组对组号分配的参与权。 参考：我所认识的javascript正则表达式 元字符元字符是拥有特殊含义的字符： 元字符 描述 . 匹配除 \\n 以外的任何字符（注意元字符是小数点）。 \\w 匹配大小写英文字符及数字 0 到 9 之间的任意一个及下划线，相当于 [a-zA-Z0-9_] \\W 不匹配大小写英文字符及数字 0 到 9 之间的任意一个，相当于 [^a-zA-Z0-9_] \\s 匹配任何空白字符，相当于 [ \\f\\n\\r\\t\\v] \\S 匹配任何非空白字符，相当于 [^\\s] \\b 匹配单词边界 \\B 匹配非单词边界 \\d 匹配任何 0 到 9 之间的单个数字，相当于 [0-9] \\D 不匹配任何 0 到 9 之间的单个数字，相当于 [^0-9] [\\u4e00-\\u9fa5] 匹配任意单个汉字（这里用的是 Unicode 编码表示汉字的 ) 助记： w: word s: space d: digit 量词（限定符）上面的元字符都是针对单个字符匹配的，要想同时匹配多个字符的话，还需要借助限定符。 下面是一些常见的限定符 ( 下表中 n 和 m 都是表示整数，并且 0 &lt; n &lt; m) ： 限定符 描述 {n} 匹配 n 个元字符 {n,} 匹配至少 n 个元字符 {n,m} 匹配 n 到 m 个元字符 * 匹配 0 到多个元字符，相当于 {0,} ? 匹配 0 到 1 个元字符，相当于 {0,1} + 匹配至少 1 个元字符，相当于 {1,} ^ 字符串必须以指定的字符开始 $ 字符串必须以指定的字符结束 其他 由于在正则表达式中\\、?、*、^、$、+、(、)、|、{、[等字符已经具有一定特殊意义，如果需要用它们的原始意义，则应该对它进行转义，例如希望在字符串中至少有一个“ \\ ”，那么正则表达式应该这么写： \\\\+ 。 可以将多个元字符或者原义文本字符用括号括起来形成一个分组，比如 ^(13)[4-9]\\d{8}$ 表示任意以 13 开头的移动手机号码。 另外对于中文字符的匹配是采用其对应的 Unicode 编码来匹配的，对于单个 Unicode 字符，如 \\u4e00 表示汉字“一”， \\u9fa5 表示汉字“龥”，在 Unicode 编码中这分别是所能表示的汉字的第一个和最后一个的 Unicode 编码，在 Unicode 编码中能表示 20901 个汉字。 关于 \\b 的用法，它代表单词的开始或者结尾，以字符串 123a 345b 456 789d 作为示例字符串，如果正则表达式是 \\b\\d{3}\\b，则仅能匹配 456 。 可以使用 | 来表示或的关系，例如 [z|j|q] 表示匹配 z 、 j 、 q 之中的任意一个字母。 正则验证工具： https://regexper.com/","tags":[{"name":"regexp","slug":"regexp","permalink":"https://wencaizhang.gitee.io/tags/regexp/"},{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"06-Regexp","slug":"oh-my-js/06-Regexp","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/06-Regexp/"}]},{"title":"String.prototype.search()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/06-Regexp/04-String.prototype.search/","text":"描述检测字符串中是否含有与 regexp 相匹配的文本。类似于 Regexp.prototype.test 方法。 参数 参数 描述 regexp 必需。如果传入一个非正则表达式，则会使用 new RegExp() 将其隐式转换为正则表达式对象 返回值如果匹配成功，则返回正则表达式在字符串中首次匹配项的索引。否则，返回 -1 示例1234567var reg = /java/i;'javascript'.search(reg); // 0'learn java'.search(reg); // 6'ECMAScript'.search(reg); // -1","tags":[{"name":"regexp","slug":"regexp","permalink":"https://wencaizhang.gitee.io/tags/regexp/"},{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"06-Regexp","slug":"oh-my-js/06-Regexp","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/06-Regexp/"}]},{"title":"Regexp.prototype.test()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/06-Regexp/02-Regexp.test/","text":"描述检测字符串中是否含有与 regexp 相匹配的文本。 参数 参数 描述 string 必需。要检测的字符串 返回值如果字符串 string 中含有与 regexp 匹配的文本，就返回 true，否则返回 false 示例12345var reg = /java/i;reg.test('javascript'); // 返回 truereg.test('ECMAScript'); // 返回 false 123var reg = /java$/i;reg.test('javascript'); // false","tags":[{"name":"regexp","slug":"regexp","permalink":"https://wencaizhang.gitee.io/tags/regexp/"},{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"06-Regexp","slug":"oh-my-js/06-Regexp","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/06-Regexp/"}]},{"title":"Regexp.prototype.exec()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/06-Regexp/03-Regexp.exec/","text":"描述在一个指定字符串中执行一个搜索匹配。返回一个数组或 null。 参数 参数 描述 string 必需。要匹配正则表达式的字符串。 返回值如果匹配成功，exec() 方法返回一个数组，并更新正则表达式对象的属性。 返回的数组将完全匹配成功的文本作为第一项，将正则括号里匹配成功的作为数组元素填充到后面。 如果匹配失败，返回 null。 示例返回值12345678910111213141516var str = 'leftTop';var reg = /^([a-z]*)([A-Z]\\w*)*/;var result = reg.exec(str);console.log( result );// [// 0: \"leftTop\"// 1: \"left\"// 2: \"Top\"// groups: undefined// index: 0// input: \"leftTop\"// length: 3// ] 数组第一个元素：完全匹配成功的文本 数组第二个元素：匹配到正则第一个括号内表达式的文本 数组第三个元素：匹配到正则第二个括号内表达式的文本 （以此类推……） 数组的 index 属性：匹配成功的文本首个字符在原表达式中的索引 数组的 input 属性：用于匹配正则表达式的原始字符串 返回 null1234var reg = /abc/;var str = 'javascript';var result = reg.exec(str);consle.log(result); // null 更新正则表达式对象的属性正则表达式在有 g 标志的情况下，每次执行 exec() 方法后，会更新正则表达式的 lastIndex 属性。 1234567891011121314151617181920212223242526272829var reg = /(hello \\S+)/g; // 有 g 标志var str = 'This is a hello world! This is a hello regexp!'console.log(reg.lastIndex); // 0reg.exec(str);// [// 0: \"hello world!\"// 1: \"hello world!\"// groups: undefined// index: 10// input: \"This is a hello world! This is a hello regexp!\"// length: 2// ]console.log(reg.lastIndex); // 22// 即 world! 后面的那个空格的索引reg.exec(str); // 第二次执行 exec() 时，从 reg.lastIndex 开始向后索引// [// 0: \"hello regexp!\"// 1: \"hello regexp!\"// groups: undefined// index: 33// input: \"This is a hello world! This is a hello regexp!\"// length: 2// ]","tags":[{"name":"regexp","slug":"regexp","permalink":"https://wencaizhang.gitee.io/tags/regexp/"},{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"06-Regexp","slug":"oh-my-js/06-Regexp","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/06-Regexp/"}]},{"title":"String.prototype.match()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/06-Regexp/05-String.prototype.match/","text":"描述检测字符串中是否含有与 regexp 相匹配的文本。 如果正则表达式不包含 g 标志，则 match() 方法返回值和 RegExp.exec() 返回值是相同的。 如果正则表达式包含 g 标志，则返回一个数组，包含所有匹配的字符串，而不是匹配对象（即不会返回 input 属性和 index 属性）。 参数 参数 描述 regexp 必需。如果传入一个非正则表达式，则会使用 new RegExp() 将其隐式转换为正则表达式对象 返回值见描述 示例是否包含 g 的区别123456789101112'This is a hello world!'.match(/(hello \\S+)/g); // [\"hello world!\"]var matches = /(hello \\S+)/.exec('This is a hello world!');console.log(matches);// [// 0: \"hello world!\"// 1: \"hello world!\"// groups: ined// index: 10// input: s is a hello world!\"// length: 2// ]","tags":[{"name":"regexp","slug":"regexp","permalink":"https://wencaizhang.gitee.io/tags/regexp/"},{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"06-Regexp","slug":"oh-my-js/06-Regexp","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/06-Regexp/"}]},{"title":"String.prototype.replace()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/06-Regexp/06-String.prototype.replace/","text":"描述参数 参数 描述 regexp 必需。如果传入一个非正则表达式，则会使用 new RegExp() 将其隐式转换为正则表达式对象 返回值见描述 示例是否包含 g 的区别123456789101112'This is a hello world!'.match(/(hello \\S+)/g); // [\"hello world!\"]var matches = /(hello \\S+)/.exec('This is a hello world!');console.log(matches);// [// 0: \"hello world!\"// 1: \"hello world!\"// groups: ined// index: 10// input: s is a hello world!\"// length: 2// ]","tags":[{"name":"regexp","slug":"regexp","permalink":"https://wencaizhang.gitee.io/tags/regexp/"},{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"06-Regexp","slug":"oh-my-js/06-Regexp","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/06-Regexp/"}]},{"title":"String.prototype.split()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/06-Regexp/07-String.prototype.split/","text":"描述把一个字符串分割成一个数组。 它和 Array.prototype.join() 的操作是相反的。 参数 参数 描述 regexp 必需。如果传入一个非正则表达式，则会使用 new RegExp() 将其隐式转换为正则表达式对象 返回值见描述 示例例子11234var str = 'hello world';var reg = /\\s/;str.split(reg); // [ \"hello\", \"world\" ] 例子21234var str = 'a:b:c:d';var reg = /:/;str.split(reg); // [\"a\", \"b\", \"c\", \"d\"]","tags":[{"name":"regexp","slug":"regexp","permalink":"https://wencaizhang.gitee.io/tags/regexp/"},{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"06-Regexp","slug":"oh-my-js/06-Regexp","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/06-Regexp/"}]},{"title":"Linux-ls","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-linux/01-常用命令/00-ls命令/","text":"ls命令用来显示目标列表 一些参数l: 以列表形式列出内容 1ls -l S: 按照由大到小排序 1ls -Sl Sr: 反过来，从小到大 1ls -Slr h: 如果想要将文件大小单位转化为 k 或者 M，那么就再加上一个 -h，表示 --human-readable。（便于人类阅读的方式） 1ls -Slrh","tags":[{"name":"linux","slug":"linux","permalink":"https://wencaizhang.gitee.io/tags/linux/"}],"categories":[{"name":"oh-my-linux","slug":"oh-my-linux","permalink":"https://wencaizhang.gitee.io/categories/oh-my-linux/"},{"name":"01-常用命令","slug":"oh-my-linux/01-常用命令","permalink":"https://wencaizhang.gitee.io/categories/oh-my-linux/01-常用命令/"}]},{"title":"Linux-查找","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-linux/01-常用命令/01-查找命令/","text":"一、findfind 的使用格式1find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定动作&gt; &lt;指定目录&gt;：所要搜索的目录及其子目录。默认为当前目录。 &lt;指定条件&gt;：所要搜索的文件的特征。 &lt;指定动作&gt;：对搜索结果进行特定的处理。 如果什么参数都不加，find 默认搜索当前目录及其子目录，并且不过滤任何结果，将他们全都显示在屏幕上。 find 使用实例：1 搜索当前目录（含子目录，以下同）中，所有文件名以my开头的文件： 1find -name 'index.js' 2 搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息： 1find . -name 'my*' -ls 3 搜索当前目录中，所有文件名以my开头的文件，并显示它们的详细信息： 1find . -type f -mmin -10 二、locate三、whereis四、which五、type参考：阮一峰：Linux的五个查找命令","tags":[{"name":"linux","slug":"linux","permalink":"https://wencaizhang.gitee.io/tags/linux/"}],"categories":[{"name":"oh-my-linux","slug":"oh-my-linux","permalink":"https://wencaizhang.gitee.io/categories/oh-my-linux/"},{"name":"01-常用命令","slug":"oh-my-linux/01-常用命令","permalink":"https://wencaizhang.gitee.io/categories/oh-my-linux/01-常用命令/"}]},{"title":"正则表达式使用案例","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/06-Regexp/100-regexp-demos/","text":"隐藏手机号码中间 4 位数字： 前三位数字：^(\\d{3}) 中间 4 位数字：\\d{4} 最后 4 位数字：(\\d{4})$ 子表达式：() 中的内容是一个子表达式，$1 表示第一个子表达式，$2 表示第二个子表达式，依次类推。 123var str = '18012345678'var newStr = str.replace(/^(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d&#123;4&#125;)$/, '$1****$2')console.log(newStr) // 180****5678 判断字符串是否为数字要考虑的问题： 数字有正负 数字有整数和小数之分 特殊数字 0 进一步分析： 正负：以 - 开头为负数，直接以数字开头为正数，因此可以确定正则开头部分为 /^-?/； 整数：整数的第一位应当是大于 0 的数字，如果是多位整数，则后面几位数字范围是 0-9 ，对应的正则为 /[1-9][0-9]*$/ 小数：小数有整数部分和小数部分，通过小数点 . 分隔开。通过上面分析，整数部分应该是 /[1-9][0-9]*/ 。而小数点需转义为 /\\./ 。小数部分可以全为 0 ，如 10.00 ，因此小数部分无需过多限制，对应的正则为 /[0-9]+/ 。 0：对应的正则是 /0/ 。 整数、小数、0 三种情况的逻辑关系为“或”，因此需要将他们使用 | 连接合并起来: 1var regNum = /(^-?[1-9][0-9]*$)|(^-?[1-9][0-9]*\\.[0-9]+)|(^-?0$)/ 另外，元字符 \\d 等价于 [0-9]，上面正则也可以写成这样： 1var regNum = /(^-?[1-9]\\d*$)|(^-?[1-9]\\d*\\.\\d+)|(^-?0$)/ 取出指定字符有这样一个字符串，穿插着“【男播】”、“【女播】”、“【正文】”、“同期声”、“【CLIP】”五个随机出现的词组，现在需要对这个字符串进行一些操作。 提取“【男播】”与下一个相邻词组之间的内容： 123456789var str = \"【男播】aaa【男播】bbb【女播】ccc【正文】ddd【同期声】ccc【CLIP】ddd【男播】eee【女播】fff【男播】ggg\";var reg = /男播】([^【]*)【|男播】([^【]*)$/gi;var arr = [];str.replace(reg, function (match, $1, $2) &#123; $1 ? arr.push($1) : ''; $2 ? arr.push($2) : '';&#125;)var result = arr.join(' ');console.log(result);","tags":[{"name":"regexp","slug":"regexp","permalink":"https://wencaizhang.gitee.io/tags/regexp/"},{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"06-Regexp","slug":"oh-my-js/06-Regexp","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/06-Regexp/"}]},{"title":"Linux-解压","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-linux/01-常用命令/02-解压命令/","text":"总结 文件类型 解压命令 *.tar tar -xvf *.gz gzip -d 或者 gunzip *.tar.gz 和 *.tgz tar -xzf *.bz2 bzip2 -d 或者 bunzip2 *.tar.bz2 tar -xjf *.Z uncompress *.tar.Z tar -xZf *.rar unrar e *.zip unzip 一、gzip1. 命令格式：gzip 文件名已文件 file 为例进行压缩： 1gzip file 此时 file 文件已经不存在，取而代之的是 file.gz 文件。 也就是说 gzip 不保留原文件，压缩完成之后，只剩一个压缩包，原文件已经消失不见。 2. 另外，gzip 只能压缩文件，不能压缩目录。如想要压缩 test-dir 目录，命令执行失败： 12gzip test-dir/gzip: test-dir/ is a directory -- ignored 3. 解压命令：1gunzip filename.gz 或者 1gzip -d filename.gz 二、tartar 可以用来压缩目录 压缩： -c 打包 -v 显示详细信息 -f 指定文件名 -z 打包同时压缩 解压缩命令 -x 解包 -v 显示详细信息 -f 指定解压文件 -z 解压缩 三、zipwindows Linux 平台通用压缩格式 四、bz2","tags":[{"name":"linux","slug":"linux","permalink":"https://wencaizhang.gitee.io/tags/linux/"}],"categories":[{"name":"oh-my-linux","slug":"oh-my-linux","permalink":"https://wencaizhang.gitee.io/categories/oh-my-linux/"},{"name":"01-常用命令","slug":"oh-my-linux/01-常用命令","permalink":"https://wencaizhang.gitee.io/categories/oh-my-linux/01-常用命令/"}]},{"title":"Linux-文件下载","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-linux/01-常用命令/03-下载命令/","text":"wgetwget 命令用来从指定的 URL 下载文件 curl","tags":[{"name":"linux","slug":"linux","permalink":"https://wencaizhang.gitee.io/tags/linux/"}],"categories":[{"name":"oh-my-linux","slug":"oh-my-linux","permalink":"https://wencaizhang.gitee.io/categories/oh-my-linux/"},{"name":"01-常用命令","slug":"oh-my-linux/01-常用命令","permalink":"https://wencaizhang.gitee.io/categories/oh-my-linux/01-常用命令/"}]},{"title":"Linux-文件传输命令 - SCP","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-linux/01-常用命令/04-文件传输/","text":"场景：某些配置文件不适合放在代码库，但需要在多台服务器或个人电脑上配置一份。在个人电脑之间可以通过 QQ 发送文件，在服务器之间我们可以通过 scp 命令来实现文件传输。 假设服务器 A 的 ip 为 ip.exampleA，服务器 B 的 ip 为 ip.exampleB，登录用户都是 root。 现在需要把 A 的一份文件 /temp/config.ini 拷贝到 B 的 /temp/ 目录下 如果已经登录到 A 服务器： 1scp /temp/config.ini root@ip.exampleB:/temp/ 如果没有登录 A 而是登录 B 服务器： 1scp root@ip.exampleA:/temp/config.ini /temp/ 如果既没有登录 A 也没有登录 B，而是登录在不相干的服务 C 上面： 1scp root@ip.exampleA:/temp/config.ini root@ip.exampleB:/temp/ 总结一下，scp 命令的模式为：scp + 文件现在的路径 + 拷贝的目标路径。如果文件和执行命令的环境在同一个系统之下，可以使用相对路径或绝对路径（如：/temp/config.ini），如果不在同一个系统之下，则需要加上用户名和ip（如：`root@ip.exampleA:/temp`）","tags":[{"name":"linux","slug":"linux","permalink":"https://wencaizhang.gitee.io/tags/linux/"}],"categories":[{"name":"oh-my-linux","slug":"oh-my-linux","permalink":"https://wencaizhang.gitee.io/categories/oh-my-linux/"},{"name":"01-常用命令","slug":"oh-my-linux/01-常用命令","permalink":"https://wencaizhang.gitee.io/categories/oh-my-linux/01-常用命令/"}]},{"title":"alias让你事半功倍","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-linux/02-实用tips/01-设置alias/","text":"简介alias 命令可以将一段冗长的命令行简化成几个字母或者数字的缩写，这样就不用每次都输入那么多的字母和符号了，并且缩写完全都是自己设定的，非常的个性化，如果自己整理一个简单的标准出来，可以非常好的提升控制台终端中的工作效率。 示例比如：切换到 nginx 静态网站根目录的命令是： 1cd /data/wwwroot/default 通过 alias 简化，直接在命令行执行下面命令： 1alias toroot=\"cd /data/wwwroot/default\" 以后再想进入网站根目录的时候，只需输入 toroo 即可，等同于运行了 cd /data/wwwroot/default 命令。 具体设置上面示例中直接在命令行中执行 alias toroot=&quot;cd /data/wwwroot/default&quot; 仅临时有效，把当前窗口（ssh 连接）关闭之后，设置随之失效。 想要让设置永久有效，需要将其写入配置文件中，修改文件 ~/.bashrc 或者 /etc/bashrc，将命令直接添加在文件中即可。 这两个文件的区别是：~/.bashrc 只对当前用户有效，对其他用户无效，而 /etc/bashrc 对所有用户都有效。","tags":[{"name":"linux","slug":"linux","permalink":"https://wencaizhang.gitee.io/tags/linux/"},{"name":"alias","slug":"alias","permalink":"https://wencaizhang.gitee.io/tags/alias/"}],"categories":[{"name":"oh-my-linux","slug":"oh-my-linux","permalink":"https://wencaizhang.gitee.io/categories/oh-my-linux/"},{"name":"02-实用tips","slug":"oh-my-linux/02-实用tips","permalink":"https://wencaizhang.gitee.io/categories/oh-my-linux/02-实用tips/"}]},{"title":"Linux-grep","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-linux/01-常用命令/05-grep/","text":"grep - 强大的文本搜索工具如果想在文件中搜索指定的文字，那么 grep 会助你一臂之力！ 使用模式大致为：grep + &quot;要搜索的文本&quot; + 指定的文件或目录路径 + 相应的参数。 如果要搜索的文本比较复杂，也可以使用正则表达式匹配。 示例1. 要在指定的文件 a.txt 中搜索指定文本 test ：1grep \"test\" a.txt 2. 在指定目录 temp 下查找所有包含文字 test 的文件可以使用目录的绝对路径，也可以是相对路径。假设 temp 的绝对路径是 /var/www/temp 1grep \"test\" /var/www/temp/ -r","tags":[{"name":"linux","slug":"linux","permalink":"https://wencaizhang.gitee.io/tags/linux/"}],"categories":[{"name":"oh-my-linux","slug":"oh-my-linux","permalink":"https://wencaizhang.gitee.io/categories/oh-my-linux/"},{"name":"01-常用命令","slug":"oh-my-linux/01-常用命令","permalink":"https://wencaizhang.gitee.io/categories/oh-my-linux/01-常用命令/"}]},{"title":"Linux软链接","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-linux/01-常用命令/06-软链接/","text":"为某一个文件（夹）在另一个位置建立一个链接（类似 windows 系统的快捷方式）。 具体用法：ln -s 源文件 目标文件。 应用场景为：如果我们在不同的目录用到相同的文件或者文件夹，那我们不需要在每个目录都拷贝一份文件，只需要在某个固定的地方放上该文件，然后在需要使用它的地方创建软连接即可。 软连接会保持每一处链接文件的同步性，无论你在哪一处修改了文件，都会同步到其他链接处。另外，软连接不会占用磁盘空间，只有源文件占用磁盘空间。 示例想在 /data/wwwroot/default/wencaizhang.github.io/ 创建一个链接，源文件夹为 /data/wwwroot/default/repos/hexo/docs/ 因此命令是： 1ln -s ./repos/hexo/docs ./wencaizhang.github.io/blog 删除目录软连接，注意在目录名没有 /，如果带上斜线，删除的是目录下的文件","tags":[{"name":"linux","slug":"linux","permalink":"https://wencaizhang.gitee.io/tags/linux/"}],"categories":[{"name":"oh-my-linux","slug":"oh-my-linux","permalink":"https://wencaizhang.gitee.io/categories/oh-my-linux/"},{"name":"01-常用命令","slug":"oh-my-linux/01-常用命令","permalink":"https://wencaizhang.gitee.io/categories/oh-my-linux/01-常用命令/"}]},{"title":"Linux配置全局环境变量","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-linux/02-实用tips/02-设置全局环境变量/","text":"1. 修改 /etc/profile打开文件：1vim /etc/profile 在文件末尾添加如下代码： 1export PATH=\"变量路径\" 2. 修改 .bashrc打开文件：1vim /root/.bashrc 在文件末尾添加如下代码： 1export PATH=\"变量路径\" 3. 直接在 shell 下用 export 命令修改1export PATH=\"$var_PATH\" 查看当前系统下的所有环境变量： 1export","tags":[{"name":"linux","slug":"linux","permalink":"https://wencaizhang.gitee.io/tags/linux/"}],"categories":[{"name":"oh-my-linux","slug":"oh-my-linux","permalink":"https://wencaizhang.gitee.io/categories/oh-my-linux/"},{"name":"02-实用tips","slug":"oh-my-linux/02-实用tips","permalink":"https://wencaizhang.gitee.io/categories/oh-my-linux/02-实用tips/"}]},{"title":"查看提交记录","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-git/01-基本命令/03-查看提交记录/","text":"1. 查看某个文件的提交记录修改还未提交到暂存区的时候： 1git diff &lt;filename&gt; 提交到暂存区之后： 1git diff --cache &lt;filename&gt; 或者 1git diff --staged &lt;filename&gt; commit 之后： 1git log -p &lt;filename&gt; 2. 查看某人的提交记录1git log --stat --author=someone 3. 查看某次 commit 的提交记录1git show &lt;commit-hash-id&gt; 或者 1git log -p &lt;commit-hash-id&gt;","tags":[{"name":"git","slug":"git","permalink":"https://wencaizhang.gitee.io/tags/git/"}],"categories":[{"name":"oh-my-git","slug":"oh-my-git","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/"},{"name":"01-基本命令","slug":"oh-my-git/01-基本命令","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/01-基本命令/"}]},{"title":"Git 拉取代码","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-git/01-基本命令/00-获取代码/","text":"第一种方法：直接 clone假设代码库的 git 地址为 https://example.git 1git clone https://example.git 如果想要指定代码库的文件夹名字，可以在命令后面加上目录名 1git clone https://example.git dirname 第二种方法：本地存在的目录关联到远程代码库首先需要将目录初始化成为一个 git 仓库： 1git init 与远程代码库进行关联： 1git remote add origin https://example.git","tags":[{"name":"git","slug":"git","permalink":"https://wencaizhang.gitee.io/tags/git/"}],"categories":[{"name":"oh-my-git","slug":"oh-my-git","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/"},{"name":"01-基本命令","slug":"oh-my-git/01-基本命令","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/01-基本命令/"}]},{"title":"记住密码","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-git/01-基本命令/02-记住密码/","text":"方法一：使用命令1git config --global credential.helper store 如果没有 --global 参数，则在当前项目下的 .git/config 文件中添加。 方法二：修改配置在 Git 的配置文件 .gitconfig 里面会有你先前配好的 name 和 email，只需在下面添加如下代码即可： 12[credential] helper = store Windows 系统文件路径为：C:\\Users\\Administrator\\.gitconfig Linux 下路径为：~/.gitconfig 下次再输入用户名 和密码 时，git 就会记住，从而会在配置文件 .gitconfig 的同级目录下生成一个 .git-credentials 文件，此文件将会明文储存用户名和密码。","tags":[{"name":"git","slug":"git","permalink":"https://wencaizhang.gitee.io/tags/git/"}],"categories":[{"name":"oh-my-git","slug":"oh-my-git","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/"},{"name":"01-基本命令","slug":"oh-my-git/01-基本命令","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/01-基本命令/"}]},{"title":"标签","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-git/01-基本命令/05-标签/","text":"一、查看标签：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 1. 查看标签 注意，标签不是按时间顺序列出，而是按字母排序的。 1git tag 2. 查看指定标签的详细信息1git show v1.0.1 二、创建标签默认标签是打在最新提交的 commit 上的。 1. 标签默认打在最新的 commit 上1git tag v1.0.0 2. 标签指定 commit1git tag v1.0.0 &lt;commit-id&gt; 3. 指定标签信息1git tag -a &lt;tagname&gt; -m \"balabalabala...\" 如果是多行信息，使用下面命令，会自动打开编辑器（通常是 vim）： 1git tag -a &lt;tagname&gt; 三、推送标签到远程1. 推送某个标签到远程以标签 v1.0.0 为例： 1git push origin v1.0.0 2. 一次性推送全部尚未推送到远程的本地标签1git push origin --tags 四、删除标签1. 删除本地标签1git tag -d v1.0.1 2. 删除远程标签如果标签已经推送到远程，就先从本地删除： 1git tag -d v1.0.1 然后，从远程删除： 1git push origin :refs/tags/v1.0.1","tags":[{"name":"git","slug":"git","permalink":"https://wencaizhang.gitee.io/tags/git/"}],"categories":[{"name":"oh-my-git","slug":"oh-my-git","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/"},{"name":"01-基本命令","slug":"oh-my-git/01-基本命令","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/01-基本命令/"}]},{"title":"分支","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-git/01-基本命令/04-分支/","text":"一、查看分支：1. 查看本地分支没有参数，列出本地已经存在的分支，当前分支的分支名前会有“*”号。 1git branch 2. 查看远程分支1git branch -r 3. 查看本地和远程的分支1git branch -a 二、创建和切换分支：1. 创建新的分支只创建新的分支，不会切换到新建的分支。本地新建的分支如果不推送到远程，对其他人就是不可见的。 1git branch &lt;branch-name&gt; 注意：新分支是基于当前分支而创建的，和当前分支拥有相同的提交记录。 2. 切换分支分支 &lt;branch-name&gt; 既可以是本地分支，也可以是远程仓库分支。 1git checkout &lt;branch-name&gt; 3. 创建新分支，并切换到新分支1git checkout -b &lt;branch-name&gt; 4. 将新创建的本地分支推送到远程1git push origin &lt;branch-name&gt;:&lt;branch-name&gt; 推送到远程之后，在同一代码库的其他的本地仓库中需要先执行 git fetch 或者 git pull 之后，使用 git branch -a 才能看到这个分支。 5. 拉取远程分支会在本地新建一个分支 mybranchName ，并自动切换到该本地分支 mybranchName 1git checkout -b mybranchName origin/branchName 三、删除分支：1. 删除本地分支将本地分支 &lt;branch-name&gt; 删除： 1git branch -d &lt;branch-name&gt; 如果此分支没有被 merge 到其他分支，删除操作会失败，此时可以强制删除： 1git branch -D &lt;branch-name&gt; 2. 删除远程分支。删除远程分支： 1git branch -d -r &lt;branch-name&gt; 或者，推送一个空分支到远程分支，也相当于删除远程分支： 1git push origin :&lt;branch-name&gt; 3. 删除不存在对应远程分支的本地分支假设这样一个场景： 小伙伴 A 创建本地分支 feature/a 并将其推送到远程分支 origin/feature/a 其他小伙伴在本地拉取了此分支 然后，小伙伴 A 在完成对应的功能并 merge 到主分支之后，将分支 feature/a 删除（远程和本地都删除） 当其他小伙伴再次 fetch 或者 pull 操作都不会删除他们本地的 feature/a 分支，而且 git branch -a 也看不出这个分支被删除了。 此时，使用 prune 命令可以将其从本地代码库分支记录中移除： 1git remote prune origin 还有一个更简单的命令，它在 fetch 之后将不存在的远程分支从本地代码库分支记录中移除： 1git fetch -p 但这两个命令都不会删除对应的本地分支，需手动删除。","tags":[{"name":"git","slug":"git","permalink":"https://wencaizhang.gitee.io/tags/git/"}],"categories":[{"name":"oh-my-git","slug":"oh-my-git","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/"},{"name":"01-基本命令","slug":"oh-my-git/01-基本命令","permalink":"https://wencaizhang.gitee.io/categories/oh-my-git/01-基本命令/"}]},{"title":"Array.prototype.indexOf()","date":"2017-02-19T16:28:21.000Z","path":"wiki/oh-my-js/02-Array-ES5/06-Array.indexOf/","text":"描述indexOf() 方法返回在数组中可以找到一个给定元素的第一个索引（使用全等操作符），如果不存在，则返回 -1 。 参数 参数 描述 searchElement 要查找的元素 fromIndex 可选。开始查找的位置，如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回 -1 。如果参数提供的是一个负值，则将其作为数组末尾的一个抵消，即 -1 表示从最后一个元素开始查找， -2 表示从倒数第二个元素开始查找，以此类推（查找顺序不变，仍然是从前向后查询数组）。如果抵消后的索引值仍小于 0 ，则整个数组都会被查询。默认值为 0 。 返回值首个被找到的元素在数组中的索引，若没有找到则返回 -1 。 示例返回首个被查找到的元素的索引12345678var arr = [ 'a', 'b', 'c', 'a' ];var indexB = arr.indexOf('b');var indexD = arr.indexOf('d');console.log(indexB); // 1console.log(indexD); // -1 严格相等1234567var arr = [1, 2, 3];var indexStr = arr.indexOf('2');var indexNum = arr.indexOf(2);console.log(indexStr); // -1console.log(indexNum); // 1 使用 fromeIndex 参数1234567var arr = [ 'a', 'b', 'c', 'b', 'a' ];var indexB1 = arr.indexOf('b');var indexB2 = arr.indexOf('b', 2);console.log(indexB1); // 1console.log(indexB2); // 3 fromIndex 大于或等于数组长度，返回 -112345var arr = [ 'a', 'b', 'c' ];var index = arr.indexOf('a', 5);console.log(index); // -1 fromIndex 为负值123456var arr = [ 'a', 'b', 'c' ];// -1 表示从倒数第一个元素开始查找var index = arr.indexOf('a', -1);console.log(index); // -1 模拟实现1234567891011121314151617181920Array.prototype.indexOf = function (searchElement, fromIndex) &#123; var se = searchElement; var fi = parseInt(fromIndex) || 0; var arr = this; var len = arr.length; var i = 0; if (fi &gt;= len) return -1 if (fi &lt; 0) &#123; i = len + fi &#125; for (; i &lt; arr.length; i++) &#123; if (arr[i] === se) &#123; return i; &#125; &#125; return -1&#125; 拓展indexOf 存在一个局限性，就是它只能得到查找元素在数组中首次出现位置的索引，那如何得到该元素在数组中所有出现位置的索引呢？ 下面是实现方法： 12345678910111213141516171819/** 返回查找元素在数组中所有的索引组成的数组，如果数组中不存在此元素，返回空数组。*/Array.prototype.allIndexOf = function (searchElement) &#123; var arr = this; var se = searchElement; var arrIndex = []; var index = 0; for (var i = 0; i &lt; arr.length; i++) &#123; index = arr.indexOf(se, i); if (index === -1) &#123; return []; &#125; arrIndex.push(index); i = index; &#125; return arrIndex;&#125; 测试 1234var arr = [ 1, 2, 3, 2, 1];console.log( arr.allIndexOf(1) ); // [0, 4]console.log( arr.allIndexOf(9) ); // []","tags":[{"name":"js","slug":"js","permalink":"https://wencaizhang.gitee.io/tags/js/"},{"name":"array","slug":"array","permalink":"https://wencaizhang.gitee.io/tags/array/"},{"name":"es5","slug":"es5","permalink":"https://wencaizhang.gitee.io/tags/es5/"}],"categories":[{"name":"oh-my-js","slug":"oh-my-js","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/"},{"name":"02-Array-ES5","slug":"oh-my-js/02-Array-ES5","permalink":"https://wencaizhang.gitee.io/categories/oh-my-js/02-Array-ES5/"}]}]}