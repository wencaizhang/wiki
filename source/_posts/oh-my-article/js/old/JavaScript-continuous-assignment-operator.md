title: JavaScript 连续赋值
author: wencaizhang
tags:
  - javascript
  - interview
date: 2018-05-22 18:41:00
---
## 题目：下面代码的打印结果是什么

```js
var a = { n: 1 };
a.x = a = { n: 2 };
console.log(a.x);
```

<!-- more -->

## 理解：

先啰嗦两句基本知识：
1. 符号 `=` 不叫“等于号 ”，这是赋值操作，代码从右往左执行，如 `x = 10;` 就读作“把 10 赋值给变量 x“
2. 如果一个变量的数据类型是对象，那么这个变量存储的仅仅是这个对象在堆内存中的地址。

正文开始：

第一行代码：首先在堆内存中创建一个对象 `{ n: 1 }`，然后在栈内存中创建一个变量 `a` ，`a` 储存的值实际上是对象 `{ n: 1 }` 的内存地址，我们假设为 `@n1`（实际内存地址使用 4 位 16 进制表示）。

![](http://7xvule.com1.z0.glb.clouddn.com/stack01.png)

第二行代码：`.` 表示字段访问，其优先级最高。因此首先给变量 `a` 增加属性 `x`，属性 `x` 在未赋值时是 `undefined`，然后在堆内存中创建一个对象 `{ n: 2 }`，假设其内存地址为 `@n2`（如下图）。

![](http://7xvule.com1.z0.glb.clouddn.com/stack02.png)

先将这个内存地址 `@n2` 赋值给变量 `a`，然后将这个内存地址赋值给 `a.x`，但此时这个 `a.x` 指代的是内存地址为 `@n1` 的对象的属性 `x`。

![](http://7xvule.com1.z0.glb.clouddn.com/stack03.png)

第三行代码：打印 `a.x`，由于已经将内存地址为 `@n2` 赋值给了变量 `a`，并不存在属性 `x` ，因此打印结果是 `undefined` 。

## 易错点

这个问题关键点在于第二行连续赋值操作中，先操作了 `.` 运算符拿到了 `a.x` 的地址，即 `@n1` 对象的属性 `x`，然后改变了 `a` 保存的引用地址（由 `@n1` 改为 `@n2`）。

但是 `a.x` 已经优先计算出了地址，所以并没有受到影响，因此最后将内存地址 `@n2` 赋值给了 `a.x` （即 `@n1` 对象的属性 `x` )。

如果将代码稍做修改，也许更容易理解：
```js
var a = { n: 1 };
var b = a;
a.x = a = { n: 2 };
console.log(b);
```
这一次，我们关注 `@n1` 的变化，先后将 `@n1` 这个地址赋值给 `a` 和 `b`，最后打印 `b` ，结果是 `{ n: 1, x: { n: 2 } }`，这就验证了上面的理解。